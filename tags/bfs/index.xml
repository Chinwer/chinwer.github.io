<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BFS on 邱圆辉的博客</title>
    <link>https://chinwer.github.io/tags/bfs/</link>
    <description>Recent content in BFS on 邱圆辉的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 18 Jul 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://chinwer.github.io/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>BFS的两个解题模板</title>
      <link>https://chinwer.github.io/blog/bfs-template/</link>
      <pubDate>Sat, 18 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://chinwer.github.io/blog/bfs-template/</guid>
      <description>BFS模板 BFS使用队列，将每个目前未搜索的结点依次入队，然后弹出队列首部元素进行遍历，一般有两个模板：
  不需要确定当前遍历到了哪一层
while (!queue.empty()) { cur = queue.front(); queue.pop(); for (node : adjacents_of(cur)) { if (node is valid &amp;amp;&amp;amp; has not been accessed) { queue.push(node) } } } 力扣中用到此模板的常见题目有：
 二叉树的层序遍历 二叉树的最大深度    需要确定当前遍历到了哪一层
int level = 0; while (!queue.empty()) { int size = queue.size(); for (int i = 0; i &amp;lt; size; i++) { cur = queue.front(); queue.pop(); for (node : adjacents_of(cur)) { if (node is valid &amp;amp;&amp;amp; has not been accessed) { queue.</description>
    </item>
    
  </channel>
</rss>