<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on 邱圆辉的博客</title>
    <link>https://chinwer.github.io/tags/leetcode/</link>
    <description>Recent content in leetcode on 邱圆辉的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 28 Jul 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://chinwer.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>力扣总结：1140. 石子游戏 II</title>
      <link>https://chinwer.github.io/blog/leetcode-1140/</link>
      <pubDate>Tue, 28 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://chinwer.github.io/blog/leetcode-1140/</guid>
      <description>题目链接 石子游戏 II
题目描述 亚历克斯和李继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。
亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。
在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 &amp;lt;= X &amp;lt;= 2M。然后，令 M = max(M, X)。
游戏一直持续到所有石子都被拿走。
假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。
示例  输入：piles = [2,7,9,4,4]
输出：10
解释：
如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。
如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。 所以我们返回更大的 10。
 思路   动态规划状态定义
记 $n$ 为输入 $piles$ 的长度，即石子堆的个数，定义一个 $n \times n$ 的二维 $dp$ 数组，其中 $dp[i][j]$ 代表当剩下的石子堆为 $piles[i&amp;hellip;n - 1]$ 且 $M = j$ 时当前玩家能拿到的最大石子数目。</description>
    </item>
    
    <item>
      <title>力扣总结：877. 石子游戏</title>
      <link>https://chinwer.github.io/blog/leetcode-877/</link>
      <pubDate>Tue, 28 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://chinwer.github.io/blog/leetcode-877/</guid>
      <description>题目链接 石子游戏
题目描述 亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 $piles[i]$ 。
游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。
亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。
假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 $true$，当李赢得比赛时返回 $false$。
示例  输入：[5, 3, 4, 5]
输出：true
解释：
亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。
 思路一   动态规划状态的定义
此思路来自这里，简单来说，此思路核心为一个二维的 $n\times n$ 的 $dp$ 数组，数组中每个元素均为一个 $pair$ 对，其中：
 $dp[i][j].first$ 表示对于 $piles[i&amp;hellip;j]$ 这部分石头堆，先手能获得的最高分数。 $dp[i][j].</description>
    </item>
    
    <item>
      <title>力扣总结：105. 从前序与中序遍历序列构造二叉树</title>
      <link>https://chinwer.github.io/blog/leetcode-105/</link>
      <pubDate>Sun, 19 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://chinwer.github.io/blog/leetcode-105/</guid>
      <description>题目链接 105. 从前序遍历与中序遍历序列构造二叉树
题目要求 根据一棵树的前序遍历与中序遍历构造二叉树，你可以假设树中没有重复元素。
思路   递归版本
  核心思路
  $preorder$ 前序遍历序列的第一项肯定是根节点：[根 | 左 | 右]；
  根据根节点在 $inorder$ 中序遍历序列中的位置，将其分割为 [左 | 根 | 右] 三个部分；
  通过 $inorder$ 中确定的左右子树的结点个数，在 $preorder$ 中确定左右子树的序列；
  对左右子树，递归重复上述操作。
    c++代码
struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; class Solution { public: TreeNode* buildTree(vector&amp;lt;int&amp;gt;&amp;amp; preorder, vector&amp;lt;int&amp;gt;&amp;amp; inorder) { map&amp;lt;int, int&amp;gt; pos; int presize = preorder.</description>
    </item>
    
    <item>
      <title>BFS的两个解题模板</title>
      <link>https://chinwer.github.io/blog/bfs-template/</link>
      <pubDate>Sat, 18 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://chinwer.github.io/blog/bfs-template/</guid>
      <description>BFS模板 BFS使用队列，将每个目前未搜索的结点依次入队，然后弹出队列首部元素进行遍历，一般有两个模板：
  不需要确定当前遍历到了哪一层
while (!queue.empty()) { cur = queue.front(); queue.pop(); for (node : adjacents_of(cur)) { if (node is valid &amp;amp;&amp;amp; has not been accessed) { queue.push(node) } } } 力扣中用到此模板的常见题目有：
 二叉树的最大深度    需要确定当前遍历到了哪一层
int level = 0; while (!queue.empty()) { int size = queue.size(); for (int i = 0; i &amp;lt; size; i++) { cur = queue.front(); queue.pop(); for (node : adjacents_of(cur)) { if (node is valid &amp;amp;&amp;amp; has not been accessed) { queue.</description>
    </item>
    
    <item>
      <title>力扣总结：1248. 统计优美子数组</title>
      <link>https://chinwer.github.io/blog/leetcode-1248/</link>
      <pubDate>Mon, 13 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://chinwer.github.io/blog/leetcode-1248/</guid>
      <description>方法一：数学   思路和算法
  用一个 $odd$ 数组记录第 $i$ 个奇数的下标。因此子数组 $[odd[i], odd[i+k-1]]$ 恰好包含 $k$ 个奇数 ；
  同时，子数组 $(odd[i-1], odd[i])$ 及 $(odd[i+k-1], odd[i+k])$ 均为偶数。因此所有起始点为第 $i$ 个奇数的“优美”数组的个数即为：
    c++代码
class Solution { public: int numberOfSubarrays(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { vector&amp;lt;int&amp;gt; odds = { -1 }; int size = nums.size(); for (int i = 0; i &amp;lt; size; i++) { if (nums[i] &amp;amp; 1) { // nums[i] is an odd number  odds.</description>
    </item>
    
    <item>
      <title>力扣总结：5. 最长回文子串</title>
      <link>https://chinwer.github.io/blog/leetcode-5/</link>
      <pubDate>Mon, 13 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://chinwer.github.io/blog/leetcode-5/</guid>
      <description>题目要求 给定一个字符串 $s$ ，找到 $s$ 中最长的回文子串。你可以假设 $s$ 的最大长度为1000
思路 一、动态规划法   核心思路
 如果一个字符串的头尾两个字符不一样，则它一定不是回文的； 否则：  如果里面的子串是回文，则整体为回文； 否则不是回文。      状态转移方程
记 $dp[i][j]$ 表示子串 $s[i..j]$ 是否为回文子串，则有：
dp[i][j] = (s[i] == s[j]) &amp;amp;&amp;amp; dp[i + 1][j - 1]   边界条件
当 $s[i] == s[j]$ 且 $j - i &amp;lt; 3$ 时直接有： $dp[i][j] = true$
  原题解
动态规划法
  二、中心扩散法   核心思路
遍历每一个索引，以其为中心向两边进行扩散。枚举中心位置的复杂度为 $O(n)$ ，从中心位置得到回文子串的复杂度为 $O(n)$，因此整体复杂度为 $O(N^2)$ 。</description>
    </item>
    
  </channel>
</rss>