[{
    "title": "力扣总结：956. 最高的广告牌",
    "date": "August 17, 2020",
    "description": "第956题的思路总结",
    "body": "题目链接 956. 最高的广告牌\n题目描述 你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。\n你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。\n返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。\n示例 输入：[1,2,3,6]\r输出：6\r解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。\r思路一   思路来源\n来源一，来源二\n  状态定义\ndp[i][j]：将前 i 个钢管分成两个集合，集合值为 j 时，子集和的最大值\r  状态转移\n  不用第 $i$ 个钢管，此时有： $$ dp[i][j] = dp[i - 1][j] $$\n  把第 $i$ 个钢管放在子集和较大的一边，此时有： $$ dp[i][k] = max(dp[i][k], dp[i - 1][j] + rods[i]), k = j + rods[i] $$\n  把第 $i$ 个钢管放在子集和较小的一边，此时有： $$ dp[i][k] = max(dp[i][k], dp[i - 1][k] + rods[i]), k = abs(j - rods[i]) $$\n    细节\n 两层循环，先遍历每根钢管，再遍历所有可能的差值； 当两个集合的差值为 $j$ 时，要求最大和 $dp[i - 1][j]$ 要大于 $j$ 才有意义。 最后返回 $dp[n][0] / 2$。    c++代码\n二维dp版本：\nclass Solution { public: int tallestBillboard(vector\u0026lt;int\u0026gt;\u0026amp; rods) { int n = rods.size(); int sum = accumulate(rods.begin(), rods.end(), 0); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, vector(sum + 1, 0)); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= sum; j++) { if (dp[i - 1][j] \u0026lt; j) { continue; } dp[i][j] = max(dp[i][j], dp[i - 1][j]); int k = j + rods[i - 1]; dp[i][k] = max(dp[i][k], dp[i - 1][j] + rods[i - 1]); k = abs(j - rods[i - 1]); dp[i][k] = max(dp[i][k], dp[i - 1][j] + rods[i - 1]); } } return dp[n][0] / 2; } }; 优化为一维版本：\nclass Solution { public: int tallestBillboard(vector\u0026lt;int\u0026gt;\u0026amp; rods) { int n = rods.size(); int sum = accumulate(rods.begin(), rods.end(), 0); vector\u0026lt;int\u0026gt; dp(sum + 1, 0); for (int i = 0; i \u0026lt; n; i++) { vector\u0026lt;int\u0026gt; tmp = dp; for (int j = 0; j \u0026lt;= sum; j++) { if (tmp[j] \u0026lt; j) { continue; } int k = j + rods[i]; dp[k] = max(dp[k], tmp[j] + rods[i]); k = abs(j - rods[i]); dp[k] = max(dp[k], tmp[j] + rods[i]); } } return dp[0] / 2; } };   思路二   思路来源\n具体思路我就懒得重复了，直接看原作者写的吧：来源\n  c++代码\nclass Solution { public: int tallestBillboard(vector\u0026lt;int\u0026gt; \u0026amp;rods) { int n = rods.size(); unordered_map\u0026lt;int, int\u0026gt; dp; dp[0] = 0; for (int rod : rods) { auto tmp = dp; for (auto it = tmp.begin(); it != tmp.end(); it++) { int key = it-\u0026gt;first; int val = it-\u0026gt;second; dp[key - rod] = max(dp[key - rod], tmp[key]); dp[key + rod] = max(dp[key + rod], tmp[key] + rod); } } return dp[0]; } };   ",
    "ref": "/blog/leetcode-956/"
  },{
    "title": "力扣总结：650. 只有两个键的键盘",
    "date": "August 10, 2020",
    "description": "第650题的思路总结",
    "body": "题目描述 最初在一个记事本上只有一个字符 \u0026lsquo;A\u0026rsquo;。你每次可以对这个记事本进行两种操作：\n Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。 Paste (粘贴) : 你可以粘贴你上一次复制的字符。 给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出 恰好 n 个 \u0026lsquo;A\u0026rsquo;。输出能够打印出 n 个 \u0026lsquo;A\u0026rsquo; 的最少操作次数。  示例 输入: 3\r输出: 3\r解释:\r最初, 我们只有一个字符 'A'。\r第 1 步, 我们使用 Copy All 操作。\r第 2 步, 我们使用 Paste 操作来获得 'AA'。\r第 3 步, 我们使用 Paste 操作来获得 'AAA'。\r思路一 具体思路就懒得写了，反正是写给自己看的，详情可参考题解：动态规划。\n  dp 数组定义\ndp[i][j]: 要使得当前记事本上 'A' 的个数为 i，且缓冲区 'A' 的个数为 j 的最小步数\r  状态转移方程为：\ndp[i][j] = min(dp[i - j][j] + 1, dp[i][j]), j \u0026lt; i\r  c++代码：\nclass Solution { public: int minSteps(int n) { if (!n) { return 0; } // dp[i][j]: there are i \u0026#39;A\u0026#39;s on screen, and j \u0026#39;A\u0026#39;s in cache  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, vector(n + 1, n)); dp[1][0] = 0; dp[1][1] = 1; for (int i = 1; i \u0026lt;= n; i++) { int min_ = dp[i][0]; for (int j = 1; j \u0026lt; i; j++) { dp[i][j] = min(dp[i][j], dp[i - j][j] + 1); min_ = min(min_, dp[i][j]); } dp[i][i] = min_ + 1; } return dp[n][n] - 1; } };   思路二 题解链接：题解。\n  dp 数组定义\ndp[i]: 让屏幕上出现 i 个 'A' 的最小步数\r  状态转移方程\ndp[i] = min(dp[i], dp[j] + i / j), i % j == 0\r  c++代码\nclass Solution { public: int minSteps(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, n); dp[0] = dp[1] = 0; for (int i = 2; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt; i; j++) { if (i % j == 0) { dp[i] = min(dp[i], dp[j] + i / j); } } } return dp[n]; } };   思路三 题解链接：官方题解。\n思路就是这个题的答案其实是将 n 进行质因数分解，然后得到的所有质因子的和。\n  c++代码\nclass Solution { public: int minSteps(int n) { int res = 0, d = 2; while (n \u0026gt; 1) { if (n % d == 0) { res += d; n /= d; } d++; } return res; } };   ",
    "ref": "/blog/leetcode-650/"
  },{
    "title": "几个矩阵有关的题",
    "date": "August 9, 2020",
    "description": "总结一下力扣里面几个跟矩阵有关的题",
    "body": "第1139题 题目链接 1139. 最大的以1为边界的正方形\n题目描述 给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。\n示例 输入：grid = [[1,1,1],[1,0,1],[1,1,1]]\r输出：9\r输入：grid = [[1, 1, 0, 0]]\r输出：1\r思路 DP数组的定义\ndp[i][j][0]: i,j左边连续的1的个数（包括自身）\rdp[i][j][1]: i,j上边连续的1的个数（包括自身）\r思路来自于题解 Java动态规划。\nc++代码 class Solution { public: int largest1BorderedSquare(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { if (grid.empty()) { return 0; } int res = 0; int m = grid.size(); int n = grid[0].size(); vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; dp(m + 1, vector(n + 1, vector(2, 0))); for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (grid[i - 1][j - 1]) { dp[i][j][0] = dp[i][j - 1][0] + 1; dp[i][j][1] = dp[i - 1][j][1] + 1; int len = min(dp[i][j][0], dp[i][j][1]); while (len \u0026gt; res) { if (dp[i - len + 1][j][0] \u0026gt;= len \u0026amp;\u0026amp; dp[i][j - len + 1][1] \u0026gt;= len) { break; } len--; } res = max(res, len); } } } return res * res; } }; 几个注意点 写一下做了几个与这个类似的题之后，我的一些个人总结。\n  这个题考察的是一个以1为边界的方阵，而与方阵边界内的元素无关。\n  需要定义一个三维数组来记录每个点向左和向上的最大连续1的个数。\n  数组的前两维的维度要比 grid 数组的两个维度大一，这样不用考虑边界情况。\n  每次找到当前点左边和上边最大连续1的个数后，要不断缩小这个方阵的边长，直到这个方阵的边界都为1。\n具体判断条件见 while 循环里面的 if 判断条件。\n  第1740题 题目链接 面试题17.23. 最大黑方阵\n题目描述 给定一个方阵，其中每个单元(像素)非黑即白。设计一个算法，找出 4 条边皆为黑色像素的最大子方阵。\n返回一个数组 [r, c, size] ，其中 r, c 分别代表子方阵左上角的行号和列号，size 是子方阵的边长。若有多个满足条件的子方阵，返回 r 最小的，若 r 相同，返回 c 最小的子方阵。若无满足条件的子方阵，返回空数组。\n示例 示例一\r输入:\r[\r[1,0,1],\r[0,0,1],\r[0,0,1]\r]\r输出: [1,0,2]\r解释: 输入中 0 代表黑色，1 代表白色，标粗的元素即为满足条件的最大子方阵\r示例二\r输入:\r[\r[0,1,1],\r[1,0,1],\r[1,1,0]\r]\r输出: [0,0,1]\r思路 DP数组的定义\ndp[i][j][0]: i,j右边连续的1的个数（包括自身）\rdp[i][j][1]: i,j下边连续的1的个数（包括自身）\r思路来自于题解 c++动态规划。\nc++代码 class Solution { public: vector\u0026lt;int\u0026gt; findSquare(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int n = matrix.size(); if (!n) { return {}; } int r = -1, c = -1, max_len = 0; // dp[i][j][0]: right  // dp[i][j][1]: down  vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; dp(n + 1, vector(n + 1, vector(2, 0))); for (int i = n - 1; i \u0026gt;= 0; i--) { for (int j = n - 1; j \u0026gt;= 0; j--) { if (matrix[i][j]) { continue; } dp[i][j][0] = dp[i][j + 1][0] + 1; dp[i][j][1] = dp[i + 1][j][1] + 1; int len = min(dp[i][j][0], dp[i][j][1]); while (len \u0026gt;= max_len) { if (dp[i + len - 1][j][0] \u0026gt;= len \u0026amp;\u0026amp; dp[i][j + len - 1][1] \u0026gt;= len) { r = i; c = j; max_len = len; break; } len--; } } } if (r == -1) { return {}; } return { r, c, max_len }; } }; 几个注意点  这个题跟上面那个十分类似，不同点在于需要从下往上，从右往左遍历原矩阵。而上面那个题则是从上往下，从左往右遍历。 同样 dp 数组的维度要比原矩阵的大1，便于边界处理。 注意如果矩阵中没有黑像素点，即0，要返回一个空数组。  第1277题 题目链接 1277. 统计全为1的正方形子矩阵\n题目描述 给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。\n示例 输入：matrix =\r[\r[0,1,1,1],\r[1,1,1,1],\r[0,1,1,1]\r]\r输出：15\r解释： 边长为 1 的正方形有 10 个。\r边长为 2 的正方形有 4 个。\r边长为 3 的正方形有 1 个。\r正方形的总数 = 10 + 4 + 1 = 15.\r思路 DP数组的定义：\ndp[i][j]: 以matrix[i][j]为右下角的正方形子矩阵的最大边长\r状态转移方程：\ndp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\r思路来自于官方题解：统计全为1的正方形子矩阵。\nc++代码 class Solution { public: int countSquares(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int res = 0; int m = matrix.size(); int n = matrix[0].size(); // dp[i][j]: maximum length of square matrix of all ones  // with matrix[i][j] as its lower right corner  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector(n, 0)); // base case: the first row  for (int i = 0; i \u0026lt; n; i++) { if (matrix[0][i]) { res++; dp[0][i] = 1; } } // base case: the first column  for (int i = 1; i \u0026lt; m; i++) { if (matrix[i][0]) { res++; dp[i][0] = 1; } } for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { if (!matrix[i][j]) { continue; } int len = _min( dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1] ); dp[i][j] = len + 1; res += dp[i][j]; } } return res; } int _min(int a, int b, int c) { return min(a, min(b, c)); } }; 几个注意点  这个题跟上面两个不同，考察的是全为1的子矩阵。 递推时不再需要同时考虑两个方向上最大连续1的个数，只需要考虑两者的最小值，也就是子矩阵的边长。 这里 dp 的维度与原矩阵相同就可以了，这样边界处理同样很方便。  第1504题 题目链接 1504. 统计全1子矩形\n题目描述 给你一个只包含 0 和 1 的 rows * columns 矩阵 mat ，请你返回有多少个 子矩形 的元素全部都是 1 。\n示例 输入：mat = [[1,0,1],\r[1,1,0],\r[1,1,0]]\r输出：13\r解释：\r有 6 个 1x1 的矩形。\r有 2 个 1x2 的矩形。\r有 3 个 2x1 的矩形。\r有 1 个 2x2 的矩形。\r有 1 个 3x1 的矩形。\r矩形数目总共 = 6 + 2 + 3 + 1 + 1 = 13 。\r思路 这题乍一看跟上面那个一模一样，但其实这里要数的是全1的矩形个数，而不像上一题一样非得是正方形。因此会比上面那个稍微麻烦一丢丢，但总体思路还是很相似的。\nDP数组定义：\ndp[i][j]: (i, j)左边最大连续1的个数（包括自身）\r我们进一步统计以 (i, j) 作为全1矩阵右下角的所有矩阵的个数。\n统计方法是枚举矩阵的高，其可能取值为 [1, i + 1]。\n具体解释参见官方题解：统计全1子矩形\nc++代码 class Solution { public: int numSubmat(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mat) { int m = mat.size(); int n = mat[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector(n, 0)); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (!mat[i][j]) { continue; } if (!j) { dp[i][j] = 1; } else { dp[i][j] = dp[i][j - 1] + 1; } } } int res = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { int min_ = 150; for (int k = 0; k \u0026lt;= i; k++) { min_ = min(min_, dp[i - k][j]); res += min_; } } } return res; } }; 几个注意点   这个题跟上一题一样，关心矩阵内所有的元素，而不仅仅是边界元素。\n  同样，dp 数组的维度跟原矩阵保持一样就可以了。\n  注意统计以 (i, j) 作为矩形右下角的所有全1矩形个数的方法。（代码的20到28行）\n  我第一次AC的代码中同时考虑了 (i, j) 左边和上边最大连续1的个数，看了题解后才发现其实只需记录一个方向上的就够了，所以如果修改 dp 的定义为：\ndp[i][j]: (i, j)上边最大连续1的个数\r也是可以的。这样的话，每次统计矩形个数时就是枚举矩形的宽而不是高了，思路还是没变。\n  总结 总之这几个与矩阵有关的题难度都不大，并且思路都有一个共同点：\ndp[i][j] 表示的都是 (i, j) 左/上/右/下 边最大连续 1/0 的个数 ，区别主要有以下几点：\n  遍历矩阵的顺序：从上往下还是从下往上，从左往右还是从右往左\n  dp 数组的维度：是否比原矩阵的维度大1，关键在于怎么定义 dp 数组的大小更有利于边界情况的处理，这里可以简单记忆如下：\n 如果只考虑边界元素，就定义成比原矩阵维度大1。 如果还要考虑中间元素，就定义成与原矩阵一样大。    如果只考虑边界元素，在得到 dp[i][j] 的值后，需要不断缩小可能的矩形边长直到满足题目要求；\n如果还要考虑中间元素，在得到 dp[i][j] 后，便可直接根据它来计算结果了。\n  ",
    "ref": "/blog/leetcode-matrix/"
  },{
    "title": "前缀和模板",
    "date": "August 8, 2020",
    "description": "一维前缀和以及二维前缀和的代码模板",
    "body": "一维前缀和 vector\u0026lt;int\u0026gt; one_dimension_prefix(vector\u0026lt;int\u0026gt; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; prefix(n + 1); for (int i = 1; i \u0026lt;= n; i++) { prefix[i] = prefix[i - 1] + nums[i - 1]; } return prefix; } 二维前缀和 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; two_dimension_prefix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; nums) { int m = nums.size(); int n = nums[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; prefix(m + 1, vector(n + 1, 0)); for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { prefix[i][j] = nums[i][j] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1]; } } return prefix; } ",
    "ref": "/blog/prefix-sum/"
  },{
    "title": "力扣总结：1372. 二叉树的最长交错路径",
    "date": "August 2, 2020",
    "description": "第1372题的思路总结",
    "body": "题目链接 二叉树的最长交错路径\n题目描述 给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：\n 选择二叉树中 任意 节点和一个方向（左或者右）。 如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。 改变前进方向：左变右或者右变左。 重复第二步和第三步，直到你在树中无法继续移动。 交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）。  请你返回给定树中最长 交错路径 的长度。\n思路 以下两种思路均来源于 官方题解。\nDFS   核心思路\n采用深度优先搜索的策略，从上到下遍历整棵树，遍历的同时维护变量 $is\\_left$ 和 $len$ ，其含义如下：\n $is\\_left$ ：当前节点是否应该往左走。 $len$ ：当目前为止，已经满足要求的交错路径的长度。  对于当前节点，如果应该往左走，也就是 $is\\_left$ 为 $true$，并且它有左孩子，就往左走，并且 $len$ 加一，否则如果有右孩子的话就往右走，同时将 $len$ 重置为1。$is\\_left$ 为 $false$ 时对称处理。\n  c++代码\nclass Solution { private: int res = 0; public: int longestZigZag(TreeNode* root) { if (!root) { return 0; } dfs(root, true, 0); dfs(root, false, 0); return res; } void dfs(TreeNode *root, bool is_left, int len) { res = max(res, len); if (is_left) { if (root-\u0026gt;left) { dfs(root-\u0026gt;left, false, len + 1); } if (root-\u0026gt;right) { dfs(root-\u0026gt;right, true, 1); } } else { if (root-\u0026gt;right) { dfs(root-\u0026gt;right, true, len + 1); } if (root-\u0026gt;left) { dfs(root-\u0026gt;left, false, 1); } } } };   几个注意的地方\n  为什么初始调用 dfs 时传入的 len 是 0 不是 1 ？\n因为初始调用时 root 没有父节点，当前走过的路径长度为 0。\n  为什么重置 len 时是重置为 1 而不是 0 ？\n因为此时已经从当前节点走到了它的孩子节点，已经走过了一条长度为 1 的边。\n    BFS动态规划   核心思路\n记 ：\n $f(u)$ 为从根到节点 $u$ 的路径上以 $u$ 结尾并且 $u$ 是它父节点的左孩子的最长交错路径的长度。 $g(u)$ 为从根到节点 $u$ 的路径上以 $u$ 结尾并且 $u$ 是它父节点的右孩子的最长交错路径的长度。  记 $u$ 的父节点为 $father(u)$ ，状态转移方程为： $$ f[u] = g[father(u)] + 1 \\\\\ng[u] = f[father(u)] + 1 $$ 遍历时用二元组 (child, parent) 作为状态，其中 child 表示 f 和 g 中待计算的节点，parent 为它的父节点。\n  c++代码\nclass Solution { private: // f(u) is the length of longest zigzag path from root  // to u with u being the left child of its parent node.  // g(u) is the length of longest zigzag path from root  // to u with u being the right child of its parent node.  unordered_map\u0026lt;TreeNode *, int\u0026gt; f, g; public: int longestZigZag(TreeNode* root) { bfs_dp(root); int res = 0; for (const auto \u0026amp;u : f) { res = max(res, max(u.second, g[u.first])); } return res; } void bfs_dp(TreeNode *root) { queue\u0026lt;pair\u0026lt;TreeNode *, TreeNode *\u0026gt;\u0026gt; q; f[root] = g[root] = 0; q.push({ root, nullptr }); while (!q.empty()) { auto fr = q.front(); q.pop(); auto child = fr.first; auto parent = fr.second; f[child] = g[child] = 0; // state transfer equation:  // f[child] = g[father(child)] + 1; (u is the left child)  // g[child] = f[father(child)] + 1; (u is the right child)  if (parent) { if (parent-\u0026gt;left == child) { f[child] = g[parent] + 1; } if (parent-\u0026gt;right == child) { g[child] = f[parent] + 1; } } if (child-\u0026gt;left) { q.push({ child-\u0026gt;left, child }); } if (child-\u0026gt;right) { q.push({ child-\u0026gt;right, child }); } } } };   下面的思路来自于题解区\n自底向上DFS树形DP   核心思路\n用 res[0] 表示当前节点下一步往左走的最大长度，res[1] 表示当前节点下一步往右走的最大程度。\n  c++代码\nclass Solution { private: int res = 0; public: int longestZigZag(TreeNode* root) { dfs_dp(root); return res; } vector\u0026lt;int\u0026gt; dfs_dp(TreeNode *root) { if (!root) { return { -1, -1 }; } vector\u0026lt;int\u0026gt; ret(2); vector\u0026lt;int\u0026gt; l = dfs_dp(root-\u0026gt;left); vector\u0026lt;int\u0026gt; r = dfs_dp(root-\u0026gt;right); ret[0] = l[1] + 1; ret[1] = r[0] + 1; res = max(res, max(ret[0], ret[1])); return ret; } };   ",
    "ref": "/blog/leetcode-1372/"
  },{
    "title": "力扣总结：1140. 石子游戏 II",
    "date": "July 28, 2020",
    "description": "第1140题的思路总结",
    "body": "题目链接 石子游戏 II\n题目描述 亚历克斯和李继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。\n亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。\n在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 \u0026lt;= X \u0026lt;= 2M。然后，令 M = max(M, X)。\n游戏一直持续到所有石子都被拿走。\n假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。\n示例  输入：piles = [2,7,9,4,4]\n输出：10\n解释：\n如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。\n如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。 所以我们返回更大的 10。\n 思路   动态规划状态定义\n记 $n$ 为输入 $piles$ 的长度，即石子堆的个数，定义一个 $n \\times n$ 的二维 $dp$ 数组，其中 $dp[i][j]$ 代表当剩下的石子堆为 $piles[i\u0026hellip;n - 1]$ 且 $M = j$ 时当前玩家能拿到的最大石子数目。\n  状态方程\n根据上述 $dp$ 数组的定义，可以得到状态方程的定义如下：\n记 $sum$ 为当前剩下的石子堆的总石子数目，则当 $M = j$ 时，当前玩家可以选择从最左边开始拿走 $x$ 堆石子，其中 $1 \\leq x \\leq 2M$ ，因此他能获得的最大石子数目 = $sum$ - 另一个人按照最优策略能拿到的最大石子数目。\n因此状态转移方程如下：\nfor (int x = 1; x \u0026lt;= 2 * M; x++) { dp[i][M] = max(dp[i][M], sum - dp[i + x][max(x, M)]); }   base case\n如果当前可以拿的最大石子堆数目（即 $2M$）大于剩下的石子堆数目，则最大得分即为剩下的石子数，因此base case即为：\nif (i + 2 * M \u0026gt;= n) { dp[i][j] = sum; }   c++代码\n明确状态定义，状态方程和base case后，可以写出如下c++代码：\nclass Solution { public: int stoneGameII(vector\u0026lt;int\u0026gt;\u0026amp; piles) { int sum = 0, n = piles.size(); // dp[i][j] means maximum score the current player can get  // when M == j and there are stones piles[i...n - 1] left  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector(n, 0)); for (int i = n - 1; i \u0026gt;= 0; i--) { sum += piles[i]; for (int j = 0; j \u0026lt; n; j++) { // base case  if (i + 2 * j \u0026gt;= n) { dp[i][j] = sum; continue; } for (int x = 1; x \u0026lt;= 2 * j; x++) { dp[i][j] = max(dp[i][j], sum - dp[i + x][max(x, j)]); } } } return dp[0][1]; } };   几个细节：\n  $dp$ 数组到底应该定义为 $n \\times n$ 还是 $(n + 1) \\times (n + 1)$呢？\n我看别人用这个思路定义的 $dp$ 数组都是 $(n + 1) \\times (n + 1)$ 的，但是我定义成 $n \\times n$ 也AC了，因此感觉还是得看题目来。\n但说实话刷题刷到现在自己也没有真正弄清这个小细节，导致每次动手写代码的时候老是很纠结，这里先写一下目前自己的理解，如果后续有更深刻更正确的理解我会再记录一下。\n总的来说，应该两者都没问题，就是看哪个用起来方便了（主要针对 $dp$ 数组与原数组的下标索引不一致的问题），是由你定义的状态的base case来定的。\n有的题的base case强调一个与0有关的状态，比如数组的前缀和中，前0个元素的和为0，前1个元素的和才是数组的第一个元素，即 $nums[0]$ 。这种情况下，开一个 $n + 1$ 的 $dp$ 数组就会比较方便。\n而这个题目中并没有强调一个与0有关的状态，事实上，根本没用到什么如果当前剩下的石子堆为第0堆到第n - 1堆时……的状态，最边界的情况也只是第1堆到第n - 1堆，只不过这个第1堆的索引为0罢了。因此定义一个 $n \\times n$ 的二维数组就够用了。\n总之如果定义数组的“边长”为 $n + 1$ 的话，需要考虑 $dp$ 数组与原数组下标索引不一致的问题：因为这种时候往往 $dp[0]/dp[0][0]$ 为base case，因此循环遍历计算 $dp$ 数组时的索引往往是从1开始的，此时代码往往长这样：\ndp[i] = ...nums[i - 1]... 而如果定义数组的“边长”为 $n$ 的话就没有这个问题。\n所以具体怎么定义还是看题目吧，实在不确定的话就先定义成 $n \\times n$ ，如果发现不行（如无法覆盖base case等情况）的话再换成 $(n + 1) \\times (n + 1)$ 也一样。\n  为什么这里base case的判断条件中是 i + 2 * j \u0026gt;= n 而不是 i + 2 * j \u0026gt;= n - 1 呢？$piles$ 的最大索引不是 $n - 1$ 吗？\n这个其实用几个具体的数组代入再稍微思考一下就会发现应该是前者：\n比如假设总共有三堆石子，然后现在 $i = 0, j = 1$，也就是说现在还剩三堆石子没拿，当前玩家最多可以拿 $2 * j = 2$ 堆石子。\n如果判断条件是后者的话这个 $if$ 判断会返回 $true$ ，意思就是说这是个base case，而根据base case的定义，也就是说当前玩家可以把剩下的石子堆全拿走，但是显然这个是不对的，因为还剩三堆但是最多只能拿两堆啊！但如果判断条件是前者的话就不会犯这个错误。\n为什么呢？首先我们要搞清楚 i + 2 * j 的含义，它的含义是说：我从第 $i$ 堆石子开始，总共拿了 $2 * j$ 堆石子后，下一个人接着开始拿时，剩下的石子堆的最小索引。\n所以如果只是 \u0026gt;= n - 1 的话说明下一个人还可以从 piles[n - 1] 这堆石子开始拿，说明当前玩家还不能把剩下的石子都拿走。\n但如果是 \u0026gt;= n 的话说明下一个人只能从 piles[n] 这堆石子开始拿了，但是 piles[n] 不存在，也就是说下一个人没有石子可拿了，即当前玩家可以把剩下的石子都拿走。\n    ",
    "ref": "/blog/leetcode-1140/"
  },{
    "title": "力扣总结：877. 石子游戏",
    "date": "July 28, 2020",
    "description": "第877题的几种思路",
    "body": "题目链接 石子游戏\n题目描述 亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 $piles[i]$ 。\n游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。\n亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。\n假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 $true$，当李赢得比赛时返回 $false$。\n示例  输入：[5, 3, 4, 5]\n输出：true\n解释：\n亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。\n 思路一   动态规划状态的定义\n此思路来自这里，简单来说，此思路核心为一个二维的 $n\\times n$ 的 $dp$ 数组，数组中每个元素均为一个 $pair$ 对，其中：\n $dp[i][j].first$ 表示对于 $piles[i\u0026hellip;j]$ 这部分石头堆，先手能获得的最高分数。 $dp[i][j].second$ 表示对于 $piles[i\u0026hellip;j]$ 这部分石头堆，后手能获得的最高分数。  因此，最终的答案为先手和后手的最终分数之差，即：\ndp[0][n - 1].first - dp[0][n - 1].second   状态方程\n根据上述 $dp$ 数组的定义，可以得到状态方程如下：\ndp[i][j].first = max(piles[i] + dp[i + 1][j].second, piles[j] + dp[i][j - 1].second) 解释：我作为先手，面对 $piles[i\u0026hellip;j]$ 时，有两种选择：\n 选择最左边的那堆石头，然后面对 $piles[i + 1\u0026hellip;j]$ 选择最右边的那堆石头，然后面对 $piles[i\u0026hellip;j - 1]$  不管哪种选择，选完后都轮到对方，即我变成了后手。\n  base case\n当只有一堆石头时，先手的得分即为那堆石头的个数，后手的得分为0：\ndp[i][i].first = piles[i]; dp[i][i].second = 0; 其中 $0 \\leq i = j \u0026lt; n$ 。\n  c++代码\n根据上述分析可写出如下代码：\nclass Solution { public: bool stoneGame(vector\u0026lt;int\u0026gt;\u0026amp; piles) { int n = piles.size(); vector\u0026lt;vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt; dp(n, vector(n, pair(0, 0))); // base case  for (int i = 0; i \u0026lt; n; i++) { dp[i][i].first = piles[i]; dp[i][i].second = 0; } for (int i = n - 2; i \u0026gt;= 0; i--) { for (int j = i + 1; j \u0026lt; n; j++) { int left = piles[i] + dp[i + 1][j].second; int right = piles[j] + dp[i][j - 1].second; if (left \u0026gt; right) { dp[i][j].first = left; dp[i][j].second = dp[i + 1][j].first; } else { dp[i][j].first = right; dp[i][j].second = dp[i][j - 1].first; } } } return dp[0][n - 1].first - dp[0][n - 1].second; } };   思路二   动态规划状态的定义\n此思路来自这里，youtube上也有这种思路的讲解视频：视频\n此思路核心同样为一个 $n \\times n$ 的二维 $dp$ 数组，其中 $dp[i][j]$ 定义为：在面对石子堆 $piles[i\u0026hellip;j]$ 时，先手与后手获得的分数差的最大值。\n  状态方程\n根据上述 $dp$ 状态的定义，可得状态方程如下：\ndp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])   base case\n当只有一堆石头时，两者得分差的最大值即为这对石头的石子数：\ndp[i][i] = piles[i]   c++代码\n根据上述分析，可写出如下代码：\nclass Solution { public: bool stoneGame(vector\u0026lt;int\u0026gt; \u0026amp;piles) { int n = piles.size(); // dp[i][j] means the maximum difference between  // the score of the first hand and second hand  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector(n, 0)); for (int i = 0; i \u0026lt; n; i++) { dp[i][i] = piles[i]; } for (int i = n - 2; i \u0026gt;= 0; i--) { for (int j = i + 1; j \u0026lt; n; j++) { dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]); } } return dp[0][n - 1] \u0026gt; 0; } };   ",
    "ref": "/blog/leetcode-877/"
  },{
    "title": "斜向遍历二维数组 ",
    "date": "July 25, 2020",
    "description": "斜向遍历二维数组的代码框架",
    "body": "在动态规划中有时会需要斜着遍历二维数组，在这里用c++简单记录一下遍历的代码：\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector(n, 0)); for (int l = 2; l \u0026lt;= n; l++) { for (int i = 0; i \u0026lt; n; i++) { int j = l + i - 1; /* Visit dp[i][j] */ } } ",
    "ref": "/blog/two-dimension-array-oblique-traversal/"
  },{
    "title": "力扣总结：105. 从前序与中序遍历序列构造二叉树",
    "date": "July 19, 2020",
    "description": "第105题的几种思路",
    "body": "题目链接 105. 从前序遍历与中序遍历序列构造二叉树\n题目要求 根据一棵树的前序遍历与中序遍历构造二叉树，你可以假设树中没有重复元素。\n思路   递归版本\n  核心思路\n  $preorder$ 前序遍历序列的第一项肯定是根节点：[根 | 左 | 右]；\n  根据根节点在 $inorder$ 中序遍历序列中的位置，将其分割为 [左 | 根 | 右] 三个部分；\n  通过 $inorder$ 中确定的左右子树的结点个数，在 $preorder$ 中确定左右子树的序列；\n  对左右子树，递归重复上述操作。\n    c++代码\nstruct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; class Solution { public: TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { map\u0026lt;int, int\u0026gt; pos; int presize = preorder.size(), insize = inorder.size(); for (int i = 0; i \u0026lt; insize; i++) { pos[inorder[i]] = i; } return build(preorder, 0, presize - 1, inorder, 0, insize - 1, pos); } TreeNode *build(vector\u0026lt;int\u0026gt; \u0026amp;pre, int prestart, int preend, vector\u0026lt;int\u0026gt; \u0026amp;in, int instart, int inend, map\u0026lt;int, int\u0026gt; \u0026amp;pos) { if (instart \u0026gt; inend || prestart \u0026gt; preend) { return nullptr; } int root_val = pre[prestart]; int root_idx = pos[root_val]; int nums_left = root_idx - instart; TreeNode *root = new TreeNode(root_val); root-\u0026gt;left = build(pre, prestart + 1, prestart + nums_left, in, instart, root_idx - 1, pos); root-\u0026gt;right = build(pre, prestart + nums_left + 1, preend, in, root_idx + 1, inend, pos); return root; } };   几个注意点\n  注意递归调用的边界条件；\n  注意递归时 $inorder, preorder$ 中左右子树的边界；\n  为了避免每次都必须遍历整个 $inorder$ 序列来寻找根节点，采用一个从数组元素到索引的映射表 $pos$ 来降低时间复杂度。\n    复杂度分析\n 时间复杂度：$O(n)$ ，其中 $n$ 是树中节点个数。 空间复杂度：$O(n)$ ，除了返回值所需要的 $O(n)$ 空间以外，还需要 $O(n)$ 来存储哈希表，及 $O(h)$ 的递归栈空间，其中 $h$ 是树的高度。因此整体空间复杂度为 $O(n)$。      递归优化版本\n此算法来自国外版讨论区：Simple O(n) without map\n  核心思路\n 变量 $pre$ 代表当前要构造的树的根节点； 变量 $in$ 代表在 $inorder$ 中，当前要构造的树的第一个节点； 变量 $stop$ 代表在 $inorder$ 中，当前要构造的树的最后一个节点（不包括 $stop$ ）； 每次递归调用都可以通过 $stop$ 变量得知当前树的构造终点，同时告诉左子树它的终点即为当前构造的树的根节点，告诉右子树它的终点为当前构造的树的终点。    c++代码\nclass Solution { private: int in = 0; int pre = 0; public: TreeNode buildTree(vector\u0026lt;int\u0026gt; \u0026amp;preorder, vector\u0026lt;int\u0026gt; \u0026amp;inorder) { return build(preorder, inorder, INT_MIN); } TreeNode build(vector\u0026lt;int\u0026gt; \u0026amp;preorder, vector\u0026lt;int\u0026gt; \u0026amp;inorder, int stop) { if (pre == preorder.size()) { return nullptr; } if (inorder[in] == stop) { in++; return nullptr; } TreeNode root = new TreeNode(preorder[pre++]); root-\u0026gt;left = build(preorder, inorder, root-\u0026gt;val); root-\u0026gt;right = build(preorder, inorder, stop); return root; } };   复杂度分析\n 时间复杂度：$O(n)$。 空间复杂度：$O(n)$，相比上述算法少了额外的用来存储哈希表的 $O(n)$ 的空间。      迭代版本\n此算法来自官方题解：从前序与中序遍历序列构造二叉树\n  核心思路\n 用一个栈和一个指向 $inorder$ 的指针 $in$ 辅助二叉树的构造。其中栈中存放的是所有尚未考虑过右儿子的节点，栈顶就是当前遍历到的 $preorder$ 中的节点。 每次判断当前遍历到的 $preorder$ 中的节点是否与 $inorder[in]$ 相等：  若相等，则说明当前已经沿着某个节点走到了它左子树的最左端了，此时不断弹出栈顶节点并右移 $in$ ，最后将当前节点作为最后一个弹出的节点的右孩子； 否则，将当前节点作为栈顶结点的左孩子； 无论哪种情况，最后都将当前节点入栈。      c++代码\nclass Solution { public: TreeNode *buildTree(vector\u0026lt;int\u0026gt; \u0026amp;preorder, vector\u0026lt;int\u0026gt; \u0026amp;inorder) { if (preorder.empty()) { return nullptr; } stack\u0026lt;TreeNode *\u0026gt; s; TreeNode *root = new TreeNode(preorder[0]); s.push(root); int in = 0, size = preorder.size(); for (int i = 1; i \u0026lt; size; i++) { int preorder_val = preorder[i]; TreeNode *node = s.top(); if (node-\u0026gt;val != inorder[in]) { node-\u0026gt;left = new TreeNode(preorder_val); s.push(node-\u0026gt;left); } else { while (!s.empty() \u0026amp;\u0026amp; s.top()-\u0026gt;val == inorder[in]) { node = s.top(); s.pop(); in++; } node-\u0026gt;right = new TreeNode(preorder_val); s.push(node-\u0026gt;right); } } return root; } }   复杂度分析\n 时间复杂度：$O(n)$ 空间复杂度：$O(n)$      ",
    "ref": "/blog/leetcode-105/"
  },{
    "title": "BFS的两个解题模板",
    "date": "July 18, 2020",
    "description": "BFS两个模板",
    "body": "BFS模板 BFS使用队列，将每个目前未搜索的结点依次入队，然后弹出队列首部元素进行遍历，一般有两个模板：\n  不需要确定当前遍历到了哪一层\nwhile (!queue.empty()) { cur = queue.front(); queue.pop(); for (node : adjacents_of(cur)) { if (node is valid \u0026amp;\u0026amp; has not been accessed) { queue.push(node) } } } 力扣中用到此模板的常见题目有：\n 二叉树的最大深度    需要确定当前遍历到了哪一层\nint level = 0; while (!queue.empty()) { int size = queue.size(); for (int i = 0; i \u0026lt; size; i++) { cur = queue.front(); queue.pop(); for (node : adjacents_of(cur)) { if (node is valid \u0026amp;\u0026amp; has not been accessed) { queue.push(node); } } } level++; } 力扣中用到此模板的常见题目有：\n 对称二叉树 路径总和 填充每个节点的下一个右侧节点指针 填充每个节点的下一个右侧节点指针 II 二叉树的所有路径 二叉树的层序遍历 二叉树的层次遍历 II 相同的树    ",
    "ref": "/blog/bfs-template/"
  },{
    "title": "二叉树的几种遍历方式总结",
    "date": "July 18, 2020",
    "description": "二叉树的先序、中序、后序及层次遍历",
    "body": "记录一下二叉树的几种遍历方式的代码模板，包括前序、中序、后序及层次遍历，均用c++实现。\n先序遍历   递归版本\nvoid preorder_traversal(TreeNode *root) { if (!root) { return; } /* Visit the current node */ preorder_traversal(root-\u0026gt;left); preorder_traversal(root-\u0026gt;right); }   迭代版本一\nvoid preorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; s.push(root); while (!s.empty()) { TreeNode *node = s.top(); s.pop(); if (node) { /* Visit the current node */ s.push(root-\u0026gt;right); s.push(root-\u0026gt;left); } } }   迭代版本二\nvoid preorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; TreeNode *node = root; while (node || !s.empty()) { while (node) { s.push(node); /* Visit the current node */ node = node-\u0026gt;left; } node = s.top(); s.pop(); node = node-\u0026gt;right; } } 注意不需要特判 $root$ 是否为空。\n  迭代优化版本\n优化思路为只对右子节点进行压栈。（这个版本有点复杂，又要判断指针是否为空，又要判断栈是否为空，建议记上面一个版本）\nvoid preorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; TreeNode *node = root; while (true) { if (node) { /* Visit the current node */ if (node-\u0026gt;right) { s.push(node-\u0026gt;right); } } else if (s.empty()) { return; } else { node = s.top(); s.pop(); } } }   力扣题目\n力扣上可套用先序遍历模板的题目有：\n 路径总和 路径总和 II 左叶子之和    中序遍历   递归版本\nvoid inorder_traversal(TreeNode *root) { if (!root) { return; } inorder_traversal(root-\u0026gt;left); /* Visit the current node */ inorder_traversal(root-\u0026gt;right); }   迭代版本\nvoid inorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; TreeNode *node = root; while (node || !s.empty()) { while (node) { s.push(node); node = node-\u0026gt;left; } node = s.top(); s.pop(); /* Visit the current node */ node = node-\u0026gt;right; } } 不需要特判 $root$ 是否为空。\n  后序遍历   递归版本\nvoid postorder_traversal(TreeNode *root) { postorder_traversal(root-\u0026gt;left); postorder_traversal(root-\u0026gt;right); /* Visit the current node */ }   迭代版本\nvoid postorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; TreeNode *node = root; TreeNode *pre = nullptr; while (node || !s.empty()) { while (node) { s.push(node); node = node-\u0026gt;left; } node = s.top(); if (!(node-\u0026gt;right) || node-\u0026gt;right == pre) { /* Visit the current node */ s.pop(); pre = node; node = nullptr; } else { node = node-\u0026gt;right; } } } 不需要特判 $root$ 是否为空。\n  力扣题目\n力扣上可套用后序遍历模板的题目有：\n 路径总和 II 检查平衡性 二叉树的最近公共祖先 二叉树的所有路径    层次遍历   递归版本(DFS)\nstruct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelorder_traversal(TreeNode *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; dfs(res, root, 0); return res; } void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;res, TreeNode *root, int level) { if (!root) { return; } if (level \u0026gt;= res.size()) { res.push_back(vector\u0026lt;int\u0026gt;()); } res[level].push_back(root-\u0026gt;val); dfs(root-\u0026gt;left, level + 1); dfs(root-\u0026gt;right, level + 1); }   迭代版本(BFS)\nvoid levelorder_traversal(TreeNode *root) { if (!root) { return; } queue\u0026lt;TreeNode *\u0026gt; q; TreeNode *cur = root; q.push(cur); while (!q.empty()) { cur = q.pop(); /* Visit the current node */ if (root-\u0026gt;lchild) { q.push(root-\u0026gt;lchild); } if (root-\u0026gt;rchild) { q.push(root-\u0026gt;rchild); } } } 注意需要特判 $root$ 是否为空。\n  先中后序遍历统一 最后附上一种将这三种遍历方式的形式统一起来的写法，原文见：秒杀全场吧，后浪\n  先序\nvoid preorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; if (root) { s.push(root); } while (!s.empty()) { TreeNode *cur = s.top(); s.pop(); if (cur) { if (cur-\u0026gt;right) { s.push(cur-\u0026gt;right); } if (cur-\u0026gt;left) { s.push(cur-\u0026gt;left); } // re-push the current node, for follow-up processing  s.push(cur); // insert an empty node before the current one  // meaning that the current node has already been accessed  s.push(nullptr); } else { /* Visit the current node */ // pop the current node out thoroughly  s.pop(); } } }   中序\nvoid preorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; if (root) { s.push(root); } while (!s.empty()) { TreeNode *cur = s.top(); s.pop(); if (cur) { if (cur-\u0026gt;right) { s.push(cur-\u0026gt;right); } s.push(cur); s.push(nullptr); if (cur-\u0026gt;left) { s.push(cur-\u0026gt;left); } } else { /* Visit the current node */ // pop the current node out thoroughly  s.pop(); } } }   后序\nvoid preorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; if (root) { s.push(root); } while (!s.empty()) { TreeNode *cur = s.top(); s.pop(); if (cur) { s.push(cur); s.push(nullptr); if (cur-\u0026gt;right) { s.push(cur-\u0026gt;right); } if (cur-\u0026gt;left) { s.push(cur-\u0026gt;left); } } else { /* Visit the current node */ // pop the current node out thoroughly  s.pop(); } } }\t  ",
    "ref": "/blog/binary-tree-traversal/"
  },{
    "title": "Chevereto安装总结",
    "date": "July 13, 2020",
    "description": "在服务器上利用Chevereto自建图床",
    "body": "Chevereto介绍 Chevereto是一款私人图床服务器软件，可以进行图片的存储、处理及分发。昨晚折腾了一个小时，终于是把Chevereto在服务器上搭好了，在此做下总结。\n安装环境 我使用的LAMP环境，具体如下：\n Linux version 4.18.0, CentOS Linux release 8.1.1911 Apache 2.4.37 (centos) Mysql 8.0.17 PHP 7.2.11  上面几个依赖的安装就不说了，基本上用yum install xxx安装就行了。\nChevereto源码安装 我的网页根目录为apache默认的/var/www/html，因此在此目录下克隆Chevereto的github项目即可。\n这里要注意正确设置克隆后的Chevereto文件夹用户权限。如我的apache服务的用户是apache，那么设置Chevereto权限如下：\nsudo chown -R apache:apache /var/www/html/Chevereto 同时，需要保证apache用户对此文件夹有写权限：\nsudo chmod -R 700 Chevereto 即只有此文件夹的所有者（apache）具有读、写以及执行的权限。\n然而实际上发现这样的话打开网页会403 Forbidden，所以直接设置所有人对此目录可读写及执行了（逃~）：\nsudo chmod -R 777 Chevereto Mysql数据库设置 为了Chevereto能够正常存储图片，需要给它专门创建一个数据库和数据库用户，这里我首先创建一个名为imagesuser的mysql用户以及一个名为images的数据库，然后授权该用户对此数据库拥有所有权限：\n 以root用户的身份登录到数据库：  mysql -u root -p 创建一个用户名为imagesuser，密码为0924的用户：  create user imagesuser identified by 0924; 创建一个名为images的数据库：  create database images; 授权该用户对此数据库拥有全部权限：  grant all on images.* to imagesuser 最大文件大小设置 Chevereto默认的最大图片大小为2MB，这显然太小了，因此首先修改php允许上传的最大文件大小：\nsudo vim /etc/php.ini 在这里面找到以下几个设置项并修改即可：\n memory_limit = 128M\nupload_max_filesize = 24M\npost_max_size = 32M\n 设置好后重启apache服务：\nsudo systemctl restart httpd\t然后进入Chevereto网页管理后台，点击\n dashboard -\u0026gt; settings -\u0026gt; image-upload\n 修改最大图片大小即可。\n一些问题 至此理论上来说访问http://[server-url]/Chevereto应该已经能够work了， 但是我实际安装过程中还遇到了以下几个问题：\n  打开网站后出现 Chevereto can’t create the app/settings.php file. You must manually create this file解决：手动创建文件/var/www/html/Chevereto/app/settings.php并设置权限：\ncd /var/www/html/Chevereto/app sudo touch settings.php sudo -R 777 settings.php   打开网站后出现G: Session are not working on this server原因：Chevereto程序没有对session目录的读写权限，session目录为配置/etc/php-fpm.d/www.conf下的：\n php_value[session.save_path] = /var/lib/php/session\n 解决：修改此目录的所属用户即用户组为apache用户及用户组即可：\ncd /var/lib/php\rsudo chown -R apache:apache session\r  打开网站后出现The requested URL /install was not found on this server，\n原因：google发现作者解释：\n Apache: Check if mod_rewrite is loaded and configured properly (allowOverride). Nginx: Make sure to add the rules that you will find in the download package.\n 解决：因此修改apache配置文件/etc/httpd/conf/httpd.conf，找到配置项：\n\u0026lt;Directory /var/www/html\u0026gt;\r......\r\u0026lt;/Directory\u0026gt;\r将其修改为：\n\u0026lt;Directory \u0026quot;/var/www/html\u0026quot;\u0026gt;\r#\r# Possible values for the Options directive are \u0026quot;None\u0026quot;, \u0026quot;All\u0026quot;,\r# or any combination of:\r# Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews\r#\r# Note that \u0026quot;MultiViews\u0026quot; must be named *explicitly* --- \u0026quot;Options All\u0026quot;\r# doesn't give it to you.\r#\r# The Options directive is both complicated and important. Please see\r# http://httpd.apache.org/docs/2.4/mod/core.html#options\r# for more information.\r#\rOptions Indexes FollowSymLinks MultiViews\r#\r# AllowOverride controls what directives may be placed in .htaccess files.\r# It can be \u0026quot;All\u0026quot;, \u0026quot;None\u0026quot;, or any combination of the keywords:\r# Options FileInfo AuthConfig Limit\r#\rAllowOverride All\r#\r# Controls who can get stuff from this server.\r#\rRequire all granted\r\u0026lt;/Directory\u0026gt;\r  至此，整个Chevereto的配置就弄好啦！然后打开网页，会提示你进行一些初始的设置：数据库的连接、图床管理用户的用户名和密码，联系邮箱等等，按照提示输入就可了，最后上一张成果图：\n",
    "ref": "/blog/chevereto/"
  },{
    "title": "力扣总结：1248. 统计优美子数组",
    "date": "July 13, 2020",
    "description": "力扣第1248题的两种思路",
    "body": "方法一：数学   思路和算法\n  用一个 $odd$ 数组记录第 $i$ 个奇数的下标。因此子数组 $[odd[i], odd[i+k-1]]$ 恰好包含 $k$ 个奇数 ；\n  同时，子数组 $(odd[i-1], odd[i])$ 及 $(odd[i+k-1], odd[i+k])$ 均为偶数。因此所有起始点为第 $i$ 个奇数的“优美”数组的个数即为：\n    c++代码\nclass Solution { public: int numberOfSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { vector\u0026lt;int\u0026gt; odds = { -1 }; int size = nums.size(); for (int i = 0; i \u0026lt; size; i++) { if (nums[i] \u0026amp; 1) { // nums[i] is an odd number  odds.push_back(i); } } odds.push_back(size); int res = 0; size = odds.size() - 1; for (int i = 1; i + k \u0026lt;= size; i++) { res += (odds[i] - odds[i - 1]) * (odds[i + k] - odds[i + k - 1]); } return res; } };   方法二：前缀和 + 差分   思路和算法\n  考虑以 $i$ 结尾的 $\\lceil 优美子数组 \\rfloor$ 个数，我们需要统计对应的起始点 $j$ 的个数，其中 $0 \\leq j \\leq i $ 且子数组 $[j..i]$ 中恰好有 $k$ 个奇数。\n  定义 $pre[i]$ 为子数组 $[0..i]$ 中奇数的个数，则递推公式为： $$ pre[i] = pre[i-1] + (nums\u0026amp;1) $$ 因此在考虑以 $i$ 结尾的 $\\lceil 优美子数组 \\rfloor$ 的个数时，只需考虑 $pre[j] = pre[i] - k$ 的 $j$ 的个数即可。\n  建立频次数组 $cnt$ 记录 $pre[i]$ 出现的次数，从左往右扫描并更新，此时以 $i$ 结尾的个数即为 $cnt[pre[i] - k]$ ，最后答案为遍历所有下标的答案之和。\n  c++代码\nclass Solution { public: int numberOfSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { vector\u0026lt;int\u0026gt; cnt; cnt.push_back(1); int res = 0, odd = 0; for (int num : nums) { odd += num \u0026amp; 1; res += odd \u0026gt;= k ? cnt[odd - k] : 0; cnt[odd]++; } return res; } };   原题解 优美子数组个数\n  ",
    "ref": "/blog/leetcode-1248/"
  },{
    "title": "力扣总结：5. 最长回文子串",
    "date": "July 13, 2020",
    "description": "第五题的两种思路",
    "body": "题目要求 给定一个字符串 $s$ ，找到 $s$ 中最长的回文子串。你可以假设 $s$ 的最大长度为1000\n思路 一、动态规划法   核心思路\n 如果一个字符串的头尾两个字符不一样，则它一定不是回文的； 否则：  如果里面的子串是回文，则整体为回文； 否则不是回文。      状态转移方程\n记 $dp[i][j]$ 表示子串 $s[i..j]$ 是否为回文子串，则有：\ndp[i][j] = (s[i] == s[j]) \u0026amp;\u0026amp; dp[i + 1][j - 1]   边界条件\n当 $s[i] == s[j]$ 且 $j - i \u0026lt; 3$ 时直接有： $dp[i][j] = true$\n  原题解\n动态规划法\n  二、中心扩散法   核心思路\n遍历每一个索引，以其为中心向两边进行扩散。枚举中心位置的复杂度为 $O(n)$ ，从中心位置得到回文子串的复杂度为 $O(n)$，因此整体复杂度为 $O(N^2)$ 。\n  原题解\n中心扩散法\n  ",
    "ref": "/blog/leetcode-5/"
  },{
    "title": "manjaro安装总结",
    "date": "September 22, 2019",
    "description": "manjaro安装过程",
    "body": "鼓捣了一天 manjaro 系统，在室友的大力帮助下终于把基本的环境、包都配置好了，在此按照系统安装之后的时间顺序稍做记录，以便后续翻阅备用。\n将 pacman 源更改为清华镜像源 pacman 为 manjaro 默认的软件包管理工具，它将一个简单的二进制包格式和易用的构建系统结合了起来。不管软件包是来自官方的 Arch 库还是用户自己创建，Pacman 都能方便的管理。\n但是 pacman 默认源在国外，因此安装包时速度会很慢，所以第一步将 pacman 的源更改为清华镜像源。\n在终端输入以下命令：\nsudo pacman-mirrors -i -c China -m rank 更新系统（所有的包） 在终端输入以下命令：\nsudo pacman -Syyu 安装 alacritty alacritty 是 linux 上一个使用 gpu 进行渲染的终端模拟器（windows 也能安装，本人没试过也不想试，有了 linux 终端谁还记得 windows 呢）。其他简介、优点说明就省了，具体安装如下：（安装包的话找 pacman 就完事儿了）\nsudo pacman -S alacritty 设置 i3 的默认终端为 alacritty（修改 i3 配置文件，文件路径见后文）：\nbindsym $mod+Return exec alacritty 找到这一行并将 exec 后的终端改为 alacritty （上面已修改）。\n安装窗口管理器 i3 i3 是 linux 系统上的一个平铺窗口管理器，简而言之在这里能够用键盘完全代替鼠标进行操作，而且还自带分屏及分屏排列等功能，完虐 windows 手动分屏功能（而且还只支持两分屏及四分屏），具体安装如下：\nsudo pacman -S i3 安装成功后 reboot，在登录界面点击设置图标可选择要进入的桌面环境（i3 或默认安装的 gnome），选择 i3 开始翱翔。\ni3 基础配置 重启后系统会进入 i3 的配置页面，如左图：\n选择 esc，即不使用默认配置。然后显示页面如右图：\n这个页面配置的是 manjaro 的 mod 键（可以和很多键位组成一些快捷键），个人建议选择 alt 键，windows 键太远，而且在机械键盘上有 lalt 和 ralt 两个键，而 windows 只有一个键。\ni3 常用快捷键及设置 在 i3 配置文件中可修改快捷键搭配方式，如：\nbindsym $mod+Shift+h move left 即设置 mod + Shift + h 为向左移动当前窗口。\n以下为我的一些个人 i3 快捷键：\n   快捷键 作用 快捷键 作用     mod + return 新建终端窗口 mod + f 全屏状态切换   mod + h 向左切换窗口 mod + shift + h 向左移动窗口   mod + j 向下切换窗口 mod + shift + j 向下移动窗口   mod + k 向上切换窗口 mod + shift + k 向上移动窗口   mod + l 向右切换窗口 mod + shift + l 向右移动窗口   mod + f 全屏状态切换 mod + d 进入软件打开界面   mod + b 打开默认浏览器 mod + s 以上下标签式（栈）排列窗口    nvi ~/.config/i3/config 其中 nvi 为 neovim 的别名，后面将介绍其相关配置。\n修改默认 shell 环境   安装 zsh\nmanjaro 默认的 shell 环境为 bash。而 zsh 环境比 bash 更方便，因此选择将默认 shell 改为 zsh。\nzsh 的介绍及配置见：终极 Shell——ZSH - 池建强的文章 - 知乎\n各系统 zsh 安装方式见：Installing ZSH\nmanjaro 系统安装 zsh 的命令同上：\nsudo pacman -S zsh   将 zsh 设置为默认 shell\nzsh 安装完成后需要将其设置为默认 shell，命令如下：\nchsh -s $(which zsh)   oh-my-zsh 的安装\noh-my-zsh 是一个 zsh 配置管理框架，可用于安装各种插件和主题更改等功能。\ngithub 主页为：oh-my-zsh\n安装很简单：\ncurl -Lo install.sh https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh 若想更换 zsh 相关配置，修改其配置文件：\nnvi ~/.zshrc 如更换主题（修改配置文件中的 ZSH_THEME 字段）：\n ZSH_THEME=\u0026quot;robbyrussell\u0026rdquo;\n 给命令设置别名（alias）：\n alias py=\u0026quot;python\u0026rdquo;\n 其中等号左边为要设置的别名，右边引号内为原始命令。\n  每次修改 zsh 配置后需要重启终端或输入以下命令应用修改：\nsource ~/.zshrc 安装 vim 用 vim 编辑文本的好处我已经不想多说了，用过的都说好啊！然而 manjaro 竟然不自带 vim，好在有 pacman 管理工具：\nsudo pacman -S vim 安装 neovim neovim 科普文章：\n科普，21 世纪的 Vim - neovim - 亦俊的文章 - 知乎\n安装命令：\nsudo pacman -S neovim 由于从零开始配置 vim 过于麻烦，因此直接使用 github 上的 thinkvim 配置。具体安装及注意事项见：\ngithub hardcoreplayers/ThinkVim\n配置 alacritty 主题 alacritty 配置文件：\n ~/.config/alacritty/alacritty.yml\n 在其中修改 colors 字段的代码即可。具体主题可见：\ngithub eendroroy/alacritty-theme\n用对应主题的配置文件中的 colors 字段覆盖上述字段。\n每次修改配置文件后重启终端即可应用修改。\n字体 修改 alacritty 配置文件中的 fonts 字段。\ncompton compton 是一个合成管理器（我也不知道什么意思），可以给 i3 窗口添加淡入淡出、半透明、阴影等效果，具体介绍见： Arch Linux - Compton\ncompton 的安装及环境依赖见： github tryone144/compton\n配置文件：\n ~/.config/compton.conf\n 修改配置文件后需要关闭重启 compton 以应用修改：\nkillall compton 然后 ctrl + d 搜索 compton 并打开。\n安装并配置好后在 i3 配置文件中添加代码如下：\nexec_always compton 即每次启动 i3 时自动启动 compton。\n其余配置   CapsLock 到 Esc 的映射 CapsLock 占据了重要的位置发挥着最少的最用，Esc 占据了最偏远的位置发着最大的作用。而在 vim 中 Esc 键又是极其重要的，因此有必要将 CapsLock 映射成 Esc。\n具体方法网上有很多教程，试了几个不管用，我个人的最终解决方法为：\n 在家目录下新建.xmodmap 文件  nvi ~./xmodmap 加入以下两行代码：  clear lock keycode 0x42 = Escape 修改 i3 配置文件：  nvi ~/.config/i3/config 添加如下代码：  exec_always xmodmap ~/.xmodmap 即每次启动 i3 时自动应用这个映射。\n但是正确的方法应该是从系统层面将 CapsLock 修改为 Escape，如 Windows 里面修改注册表的方法，但是监于本人还未找到合适方法，先用这个代替吧。\n  安装 variety 到目前为止 i3 还没有一个合适的桌面壁纸呢，因此安装 variety 壁纸管理工具：\nsudo pacman -S variety   安装 arandr arandr 是终端的一个文件浏览器，同时支持 vim 的操作语法，十分方便：\nsudo pacman -S arandr 然后在 i3 配置文件中添加：\nexec_always variety exec_always arandr  即每次启动 i3 时自动启动这两个软件。\n  关于 manjaro 的配置暂时就这么多，以后应该会安装更多软件，到时再作记录。\n总而言之这几天用着 manjaro 感觉工作效率提高了不少，一个字：爽！\n如果你目前还是一个忠实的 windows 用户，同时又是一个程序猿的话，欢迎加入 linux 大家庭！\n",
    "ref": "/blog/manjaro/"
  },{
    "title": "一篇简单的感想&总结",
    "date": "September 14, 2019",
    "description": "感想",
    "body": "最近看到一篇文章：清华大学计算机专业本科这位在「自己写的 CPU 上运行自己写的操作系统」的同学是什么水平？ - 知乎。看完后感受颇深：同龄人简历上写的项目经历，自己竟然连名字是什么意思都看不懂。还没来得及感慨贵系优秀同学与自己之间的巨大差距，今天又仔细阅读了几篇程序员大佬的编程经历回顾博客，真是感到“革命尚未成功，同志仍需努力”的任重道远之情啊！为了勉励自己继续奋力前行，在此记录一下自己这几天的阅读（围观神仙）感想。\n一、保持兴趣与热情 从小看过很多各领域精英的采访记录，具体的各种心路历程、经历分享已经记不清了， 脑海中唯独只留下了一个印象：真正站在顶峰的人，从来不是按部就班跟着老师的步伐成长起来的，更多的是兴趣使然，让自己去学习高于甚至远高于课程的知识。当然我并不是否认一步一个脚印跟着老师踏踏实实学习的重要性。相反，这是一个人成长关键的一步。一个优秀老师的悉心教导，永远胜于自己一个人拿着书本死磕。但若想做到别人做不到的事，学会别人不会的新本领，只能去课本之外寻找答案。\n今年是我在清华软院本科的第三年，当初选择计算机专业，真的是处出于纯粹的兴趣。尽管高中时除了只会用电脑上网玩游戏之外，其他计算机专业知识一窍不通，但填志愿时看着志愿书上数不清的各种专业，我的眼中只有计算机三个字。而这两年走来，虽然见识到了园子里各种各样的大佬，虽然专业课的成绩并不是那么中看，但我依然对编程，对自己的专业保持着极高的热情。而这份热情，也是激励着我每学期都比上学期更加进步的重要原因之一。\n大一上的弹幕游戏大作业、Qt小学期的怪怪水族馆游戏大作业，大二上的新闻网页信息提取大作业，前端小学期的微信小游戏开发大作业以及后端小学期的django图片处理网页的实现，所有的这些任务，几乎都是以一片空白开始，中途也少不了各种bug调试、资料搜索。虽然过程一个比一个困难，但在忍受着被bug支配的痛苦的同时，我也享受着编程带给我的快乐以及任务完成后一个比一个强烈的成就感。可曾试想，若是没有对自己所学知识的兴趣驱使着我不断前行，恐怕自己早已在这场与同龄人相互竞争、成长的博弈中草草退场。\n二、上课真的不能翘 在清华学习了两年，学到的不仅是课上老师讲授的专业知识，还有自己那自以为是的翘课本领：顶着“这课老师讲的真不怎么样”、“反正有ppt，我自己看也能学懂”的各种借口来睡懒觉、翘课、不跟着老师进度来。看了你为什么要来上课并且认真参与这篇文章后发现自己俨然就是作者所言大学生中的一个典型，同时也发现了自己其实一直有注意到但却没有留意的问题：不上课、不认真听讲带来的最直接后果便是无法集中注意力。\n不知什么时候起，我发现自己竟然很难坐在教室听老师讲完一大节甚至一小节课，很难在下定决心赶作业时坚持半个小时以上。这是自己从小“吊儿郎当”、“浮躁”的后遗症。然而进入大学两年之久，我竟没有将它改正，反而让它发展得愈加严重。\n除了注意力无法集中之外，“自学”课程知识带来的更直接的后果是对知识掌握不牢固。人家是上课认认真真听老师讲完全程，认真完成作业，甚至还会课后再次回顾巩固。而自己却是只粗粗略读课件中与作业有关的部分，直到临近考试才将一学期所有的课件临时回顾，后果便是自以为了解、掌握了的知识，在考场中根本想不起具体如何运用。\n这学期是入学以来课程数量最少的一学期，但是一看到摆在课表上的四门专业课，我只能对自己说：真的不能翘了啊喂！再翘真的就死翘翘了啊！\n三、一定要找到节奏 站在大三的起点，回顾自己大一的成绩表，真的只能用不堪入目四字来形容，都xx考的什么玩意儿！线代、微积分、程设甚至体育，都有那么难吗？如果再来一次，我还会考成那样吗?虽然知道自己的回答是不会，但我很清楚永远不会再有第二次了：如果“如果”有用的话，又要努力干什么用呢？\n所幸自己从大二开始良心发现，慢慢找到了在这个园子里生活学习的“节奏”，不仅心态变好了，学习方面也在不断进步，至少大二的专业课绩点也还勉强看得过去，前端小学期的助教和老师也大大方方给了我一个A-。（真的很开心了，自己在家一个人苦苦学习cocos、苦苦盯着屏幕一整天一整天还调不出来bug的十多天没有白费啊！）\n总而言之，除了兴趣、踏实之外，节奏是真的不能少的一个东西：找到节奏，才能安排好时间，才能好好地完成课程之内的工作，才能进一步有时间学习课程之外的新知识，而这些又会对你的学习进行“正反馈”，让你能够更加自信的面对下一阶段的生活学习。\n四、一点反思 当然写了这么多，目的不在于停下来沉浸在短时间、微小的成就上，而是要提醒自己还有很大的进步空间。比如，人家的兴趣在于独立编写行数过万的游戏、独立实现脚本引擎和Pascal语言解释器（进入 2012 \u0026ndash; 回顾我走过的编程之路），而自己的兴趣却被仅仅限制在了课程之内，根本无暇顾及课程之外更加精彩纷呈的世界。\n除此之外，注意力无法长时间集中的问题也亟待解决：一个空有一身口号，到关键时刻却永远无法专注于当下的人，永远只是一个无用之人。\n环顾四周，远比自己优秀的人比比皆是，自己的目标、家人的期望还远远没有达到，那还有什么借口继续驻足原地，止步不前呢？人生没有等出来的美丽，只有拼出来的辉煌。Wanna make it to the top? Go, now.\n",
    "ref": "/blog/blog-review/"
  },{
    "title": "Markdown Syntax Guide",
    "date": "March 11, 2019",
    "description": "Sample article showcasing basic Markdown syntax and formatting for HTML elements.",
    "body": "This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ",
    "ref": "/blog/markdown-syntax/"
  },{
    "title": "About",
    "date": "February 28, 2019",
    "description": "Hugo, the world’s fastest framework for building websites",
    "body": "Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n",
    "ref": "/about/"
  },{
    "title": "Contact",
    "date": "January 1, 0001",
    "description": "",
    "body": "",
    "ref": "/contact/"
  }]
