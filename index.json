[{
    "title": "力扣总结：105. 从前序与中序遍历序列构造二叉树",
    "date": "July 19, 2020",
    "description": "第105题的几种思路",
    "body": "题目链接 105. 从前序遍历与中序遍历序列构造二叉树\n题目要求 根据一棵树的前序遍历与中序遍历构造二叉树，你可以假设树中没有重复元素。\n思路   递归版本\n  核心思路\n  $preorder$ 前序遍历序列的第一项肯定是根节点：[根 | 左 | 右]；\n  根据根节点在 $inorder$ 中序遍历序列中的位置，将其分割为 [左 | 根 | 右] 三个部分；\n  通过 $inorder$ 中确定的左右子树的结点个数，在 $preorder$ 中确定左右子树的序列；\n  对左右子树，递归重复上述操作。\n    c++代码\nstruct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; class Solution { public: TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { map\u0026lt;int, int\u0026gt; pos; int presize = preorder.size(), insize = inorder.size(); for (int i = 0; i \u0026lt; insize; i++) { pos[inorder[i]] = i; } return build(preorder, 0, presize - 1, inorder, 0, insize - 1, pos); } TreeNode *build(vector\u0026lt;int\u0026gt; \u0026amp;pre, int prestart, int preend, vector\u0026lt;int\u0026gt; \u0026amp;in, int instart, int inend, map\u0026lt;int, int\u0026gt; \u0026amp;pos) { if (instart \u0026gt; inend || prestart \u0026gt; preend) { return nullptr; } int root_val = pre[prestart]; int root_idx = pos[root_val]; int nums_left = root_idx - instart; TreeNode *root = new TreeNode(root_val); root-\u0026gt;left = build(pre, prestart + 1, prestart + nums_left, in, instart, root_idx - 1, pos); root-\u0026gt;right = build(pre, prestart + nums_left + 1, preend, in, root_idx + 1, inend, pos); return root; } };   几个注意点\n  注意递归调用的边界条件；\n  注意递归时 $inorder, preorder$ 中左右子树的边界；\n  为了避免每次都必须遍历整个 $inorder$ 序列来寻找根节点，采用一个从数组元素到索引的映射表 $pos$ 来降低时间复杂度。\n    复杂度分析\n 时间复杂度：$O(n)$ ，其中 $n$ 是树中节点个数。 空间复杂度：$O(n)$ ，除了返回值所需要的 $O(n)$ 空间以外，还需要 $O(n)$ 来存储哈希表，及 $O(h)$ 的递归栈空间，其中 $h$ 是树的高度。因此整体空间复杂度为 $O(n)$。      递归优化版本\n此算法来自国外版讨论区：Simple O(n) without map\n  核心思路\n 变量 $pre$ 代表当前要构造的树的根节点； 变量 $in$ 代表在 $inorder$ 中，当前要构造的树的第一个节点； 变量 $stop$ 代表在 $inorder$ 中，当前要构造的树的最后一个节点（不包括 $stop$ ）； 每次递归调用都可以通过 $stop$ 变量得知当前树的构造终点，同时告诉左子树它的终点即为当前构造的树的根节点，告诉右子树它的终点为当前构造的树的终点。    c++代码\nclass Solution { private: int in = 0; int pre = 0; public: TreeNode buildTree(vector\u0026lt;int\u0026gt; \u0026amp;preorder, vector\u0026lt;int\u0026gt; \u0026amp;inorder) { return build(preorder, inorder, INT_MIN); } TreeNode build(vector\u0026lt;int\u0026gt; \u0026amp;preorder, vector\u0026lt;int\u0026gt; \u0026amp;inorder, int stop) { if (pre == preorder.size()) { return nullptr; } if (inorder[in] == stop) { in++; return nullptr; } TreeNode root = new TreeNode(preorder[pre++]); root-\u0026gt;left = build(preorder, inorder, root-\u0026gt;val); root-\u0026gt;right = build(preorder, inorder, stop); return root; } };   复杂度分析\n 时间复杂度：$O(n)$。 空间复杂度：$O(n)$，相比上述算法少了额外的用来存储哈希表的 $O(n)$ 的空间。      迭代版本\n此算法来自官方题解：从前序与中序遍历序列构造二叉树\n  核心思路\n 用一个栈和一个指向 $inorder$ 的指针 $in$ 辅助二叉树的构造。其中栈中存放的是所有尚未考虑过右儿子的节点，栈顶就是当前遍历到的 $preorder$ 中的节点。 每次判断当前遍历到的 $preorder$ 中的节点是否与 $inorder[in]$ 相等：  若相等，则说明当前已经沿着某个节点走到了它左子树的最左端了，此时不断弹出栈顶节点并右移 $in$ ，最后将当前节点作为最后一个弹出的节点的右孩子； 否则，将当前节点作为栈顶结点的左孩子； 无论哪种情况，最后都将当前节点入栈。      c++代码\nclass Solution { public: TreeNode *buildTree(vector\u0026lt;int\u0026gt; \u0026amp;preorder, vector\u0026lt;int\u0026gt; \u0026amp;inorder) { if (preorder.empty()) { return nullptr; } stack\u0026lt;TreeNode *\u0026gt; s; TreeNode *root = new TreeNode(preorder[0]); s.push(root); int in = 0, size = preorder.size(); for (int i = 1; i \u0026lt; size; i++) { int preorder_val = preorder[i]; TreeNode *node = s.top(); if (node-\u0026gt;val != inorder[in]) { node-\u0026gt;left = new TreeNode(preorder_val); s.push(node-\u0026gt;left); } else { while (!s.empty() \u0026amp;\u0026amp; s.top()-\u0026gt;val == inorder[in]) { node = s.top(); s.pop(); in++; } node-\u0026gt;right = new TreeNode(preorder_val); s.push(node-\u0026gt;right); } } return root; } }   复杂度分析\n 时间复杂度：$O(n)$ 空间复杂度：$O(n)$      ",
    "ref": "/blog/leetcode-105/"
  },{
    "title": "BFS的两个解题模板",
    "date": "July 18, 2020",
    "description": "BFS两个模板",
    "body": "BFS模板 BFS使用队列，将每个目前未搜索的结点依次入队，然后弹出队列首部元素进行遍历，一般有两个模板：\n  不需要确定当前遍历到了哪一层\nwhile (!queue.empty()) { cur = queue.front(); queue.pop(); for (node : adjacents_of(cur)) { if (node is valid \u0026amp;\u0026amp; has not been accessed) { queue.push(node) } } } 力扣中用到此模板的常见题目有：\n 二叉树的层序遍历 二叉树的最大深度    需要确定当前遍历到了哪一层\nint level = 0; while (!queue.empty()) { int size = queue.size(); for (int i = 0; i \u0026lt; size; i++) { cur = queue.front(); queue.pop(); for (node : adjacents_of(cur)) { if (node is valid \u0026amp;\u0026amp; has not been accessed) { queue.push(node); } } } level++; } 力扣中用到此模板的常见题目有：\n 对称二叉树 路径总和    ",
    "ref": "/blog/bfs-template/"
  },{
    "title": "二叉树的几种遍历方式总结",
    "date": "July 18, 2020",
    "description": "二叉树的先序、中序、后序及层次遍历",
    "body": "记录一下二叉树的几种遍历方式的代码模板，包括前序、中序、后序及层次遍历，均用c++实现。\n先序遍历   递归版本\nvoid preorder_traversal(TreeNode *root) { if (!root) { return; } /* Visit the current node */ preorder_traversal(root-\u0026gt;left); preorder_traversal(root-\u0026gt;right); }   迭代版本一\nvoid preorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; s.push(root); while (!s.empty()) { TreeNode *node = s.top(); s.pop(); if (node) { /* Visit the current node */ s.push(root-\u0026gt;right); s.push(root-\u0026gt;left); } } }   迭代版本二\nvoid preorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; TreeNode *node = root; while (node || !s.empty()) { while (node) { s.push(node); /* Visit the current node */ node = node-\u0026gt;left; } node = s.top(); s.pop(); node = node-\u0026gt;right; } }   迭代优化版本\n优化思路为只对右子节点进行压栈。\nvoid preorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; TreeNode *node = root; while (true) { if (node) { /* Visit the current node */ if (node-\u0026gt;right) { s.push(node-\u0026gt;right); } } else if (s.empty()) { return; } else { node = s.top(); s.pop(); } } }   中序遍历   递归版本\nvoid inorder_traversal(TreeNode *root) { if (!root) { return; } inorder_traversal(root-\u0026gt;left); /* Visit the current node */ inorder_traversal(root-\u0026gt;right); }   迭代版本\nvoid inorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; TreeNode *node = root; while (node || !s.empty()) { while (node) { s.push(node); node = node-\u0026gt;left; } node = s.top(); s.pop(); /* Visit the current node */ node = node-\u0026gt;right; } }   后序遍历   递归版本\nvoid postorder_traversal(TreeNode *root) { postorder_traversal(root-\u0026gt;left); postorder_traversal(root-\u0026gt;right); /* Visit the current node */ }   迭代版本\nvoid postorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; TreeNode *node = root; TreeNode *pre = nullptr; while (node || !s.empty()) { while (node) { s.push(node); node = node-\u0026gt;left; } node = s.top(); if (!(node-\u0026gt;right) || node-\u0026gt;right == pre) { /* Visit the current node */ s.pop(); pre = node; node = nullptr; } else { node = node-\u0026gt;right; } } }   层次遍历   递归版本(DFS)\nstruct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelorder_traversal(TreeNode *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; dfs(res, root, 0); return res; } void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;res, TreeNode *root, int level) { if (!root) { return; } if (level \u0026gt;= res.size()) { res.push_back(vector\u0026lt;int\u0026gt;()); } res[level].push_back(root-\u0026gt;val); dfs(root-\u0026gt;left, level + 1); dfs(root-\u0026gt;right, level + 1); }   迭代版本(BFS)\nvoid levelorder_traversal(TreeNode *root) { if (!root) { return; } queue\u0026lt;TreeNode *\u0026gt; q; TreeNode *cur = root; q.push(cur); while (!q.empty()) { cur = q.pop(); /* Visit the current node */ if (root-\u0026gt;lchild) { q.push(root-\u0026gt;lchild); } if (root-\u0026gt;rchild) { q.push(root-\u0026gt;rchild); } } }   先中后序遍历统一 最后附上一种将这三种遍历方式的形式统一起来的写法，原文见：秒杀全场吧，后浪\n  先序\nvoid preorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; if (root) { s.push(root); } while (!s.empty()) { TreeNode *cur = s.top(); s.pop(); if (cur) { if (cur-\u0026gt;right) { s.push(cur-\u0026gt;right); } if (cur-\u0026gt;left) { s.push(cur-\u0026gt;left); } // re-push the current node, for follow-up processing  s.push(cur); // insert an empty node before the current one  // meaning that the current node has already been accessed  s.push(nullptr); } else { /* Visit the current node */ // pop the current node out thoroughly  s.pop(); } } }   中序\nvoid preorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; if (root) { s.push(root); } while (!s.empty()) { TreeNode *cur = s.top(); s.pop(); if (cur) { if (cur-\u0026gt;right) { s.push(cur-\u0026gt;right); } s.push(cur); s.push(nullptr); if (cur-\u0026gt;left) { s.push(cur-\u0026gt;left); } } else { /* Visit the current node */ // pop the current node out thoroughly  s.pop(); } } }   后序\nvoid preorder_traversal(TreeNode *root) { stack\u0026lt;TreeNode *\u0026gt; s; if (root) { s.push(root); } while (!s.empty()) { TreeNode *cur = s.top(); s.pop(); if (cur) { s.push(cur); s.push(nullptr); if (cur-\u0026gt;right) { s.push(cur-\u0026gt;right); } if (cur-\u0026gt;left) { s.push(cur-\u0026gt;left); } } else { /* Visit the current node */ // pop the current node out thoroughly  s.pop(); } } }\t  ",
    "ref": "/blog/binary-tree-traversal/"
  },{
    "title": "Chevereto安装总结",
    "date": "July 13, 2020",
    "description": "在服务器上利用Chevereto自建图床",
    "body": "Chevereto介绍 Chevereto是一款私人图床服务器软件，可以进行图片的存储、处理及分发。昨晚折腾了一个小时，终于是把Chevereto在服务器上搭好了，在此做下总结。\n安装环境 我使用的LAMP环境，具体如下：\n Linux version 4.18.0, CentOS Linux release 8.1.1911 Apache 2.4.37 (centos) Mysql 8.0.17 PHP 7.2.11  上面几个依赖的安装就不说了，基本上用yum install xxx安装就行了。\nChevereto源码安装 我的网页根目录为apache默认的/var/www/html，因此在此目录下克隆Chevereto的github项目即可。\n这里要注意正确设置克隆后的Chevereto文件夹用户权限。如我的apache服务的用户是apache，那么设置Chevereto权限如下：\nsudo chown -R apache:apache /var/www/html/Chevereto 同时，需要保证apache用户对此文件夹有写权限：\nsudo chmod -R 700 Chevereto 即只有此文件夹的所有者（apache）具有读、写以及执行的权限。\n然而实际上发现这样的话打开网页会403 Forbidden，所以直接设置所有人对此目录可读写及执行了（逃~）：\nsudo chmod -R 777 Chevereto Mysql数据库设置 为了Chevereto能够正常存储图片，需要给它专门创建一个数据库和数据库用户，这里我首先创建一个名为imagesuser的mysql用户以及一个名为images的数据库，然后授权该用户对此数据库拥有所有权限：\n 以root用户的身份登录到数据库：  mysql -u root -p 创建一个用户名为imagesuser，密码为0924的用户：  create user imagesuser identified by 0924; 创建一个名为images的数据库：  create database images; 授权该用户对此数据库拥有全部权限：  grant all on images.* to imagesuser 最大文件大小设置 Chevereto默认的最大图片大小为2MB，这显然太小了，因此首先修改php允许上传的最大文件大小：\nsudo vim /etc/php.ini 在这里面找到以下几个设置项并修改即可：\n memory_limit = 128M\nupload_max_filesize = 24M\npost_max_size = 32M\n 设置好后重启apache服务：\nsudo systemctl restart httpd\t然后进入Chevereto网页管理后台，点击\n dashboard -\u0026gt; settings -\u0026gt; image-upload\n 修改最大图片大小即可。\n一些问题 至此理论上来说访问http://[server-url]/Chevereto应该已经能够work了， 但是我实际安装过程中还遇到了以下几个问题：\n  打开网站后出现 Chevereto can’t create the app/settings.php file. You must manually create this file解决：手动创建文件/var/www/html/Chevereto/app/settings.php并设置权限：\ncd /var/www/html/Chevereto/app sudo touch settings.php sudo -R 777 settings.php   打开网站后出现G: Session are not working on this server原因：Chevereto程序没有对session目录的读写权限，session目录为配置/etc/php-fpm.d/www.conf下的：\n php_value[session.save_path] = /var/lib/php/session\n 解决：修改此目录的所属用户即用户组为apache用户及用户组即可：\ncd /var/lib/php\rsudo chown -R apache:apache session\r  打开网站后出现The requested URL /install was not found on this server，\n原因：google发现作者解释：\n Apache: Check if mod_rewrite is loaded and configured properly (allowOverride). Nginx: Make sure to add the rules that you will find in the download package.\n 解决：因此修改apache配置文件/etc/httpd/conf/httpd.conf，找到配置项：\n\u0026lt;Directory /var/www/html\u0026gt;\r......\r\u0026lt;/Directory\u0026gt;\r将其修改为：\n\u0026lt;Directory \u0026quot;/var/www/html\u0026quot;\u0026gt;\r#\r# Possible values for the Options directive are \u0026quot;None\u0026quot;, \u0026quot;All\u0026quot;,\r# or any combination of:\r# Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews\r#\r# Note that \u0026quot;MultiViews\u0026quot; must be named *explicitly* --- \u0026quot;Options All\u0026quot;\r# doesn't give it to you.\r#\r# The Options directive is both complicated and important. Please see\r# http://httpd.apache.org/docs/2.4/mod/core.html#options\r# for more information.\r#\rOptions Indexes FollowSymLinks MultiViews\r#\r# AllowOverride controls what directives may be placed in .htaccess files.\r# It can be \u0026quot;All\u0026quot;, \u0026quot;None\u0026quot;, or any combination of the keywords:\r# Options FileInfo AuthConfig Limit\r#\rAllowOverride All\r#\r# Controls who can get stuff from this server.\r#\rRequire all granted\r\u0026lt;/Directory\u0026gt;\r  至此，整个Chevereto的配置就弄好啦！然后打开网页，会提示你进行一些初始的设置：数据库的连接、图床管理用户的用户名和密码，联系邮箱等等，按照提示输入就可了，最后上一张成果图：\n",
    "ref": "/blog/chevereto/"
  },{
    "title": "力扣总结：1248. 统计优美子数组",
    "date": "July 13, 2020",
    "description": "力扣第1248题的两种思路",
    "body": "方法一：数学   思路和算法\n  用一个 $odd$ 数组记录第 $i$ 个奇数的下标。因此子数组 $[odd[i], odd[i+k-1]]$ 恰好包含 $k$ 个奇数 ；\n  同时，子数组 $(odd[i-1], odd[i])$ 及 $(odd[i+k-1], odd[i+k])$ 均为偶数。因此所有起始点为第 $i$ 个奇数的“优美”数组的个数即为：\n    c++代码\nclass Solution { public: int numberOfSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { vector\u0026lt;int\u0026gt; odds = { -1 }; int size = nums.size(); for (int i = 0; i \u0026lt; size; i++) { if (nums[i] \u0026amp; 1) { // nums[i] is an odd number  odds.push_back(i); } } odds.push_back(size); int res = 0; size = odds.size() - 1; for (int i = 1; i + k \u0026lt;= size; i++) { res += (odds[i] - odds[i - 1]) * (odds[i + k] - odds[i + k - 1]); } return res; } };   方法二：前缀和 + 差分   思路和算法\n  考虑以 $i$ 结尾的 $\\lceil 优美子数组 \\rfloor$ 个数，我们需要统计对应的起始点 $j$ 的个数，其中 $0 \\leq j \\leq i $ 且子数组 $[j..i]$ 中恰好有 $k$ 个奇数。\n  定义 $pre[i]$ 为子数组 $[0..i]$ 中奇数的个数，则递推公式为： $$ pre[i] = pre[i-1] + (nums\u0026amp;1) $$ 因此在考虑以 $i$ 结尾的 $\\lceil 优美子数组 \\rfloor$ 的个数时，只需考虑 $pre[j] = pre[i] - k$ 的 $j$ 的个数即可。\n  建立频次数组 $cnt$ 记录 $pre[i]$ 出现的次数，从左往右扫描并更新，此时以 $i$ 结尾的个数即为 $cnt[pre[i] - k]$ ，最后答案为遍历所有下标的答案之和。\n  c++代码\nclass Solution { public: int numberOfSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { vector\u0026lt;int\u0026gt; cnt; cnt.push_back(1); int res = 0, odd = 0; for (int num : nums) { odd += num \u0026amp; 1; res += odd \u0026gt;= k ? cnt[odd - k] : 0; cnt[odd]++; } return res; } };   原题解 优美子数组个数\n  ",
    "ref": "/blog/leetcode-1248/"
  },{
    "title": "力扣总结：5. 最长回文子串",
    "date": "July 13, 2020",
    "description": "第五题的两种思路",
    "body": "题目要求 给定一个字符串 $s$ ，找到 $s$ 中最长的回文子串。你可以假设 $s$ 的最大长度为1000\n思路 一、动态规划法   核心思路\n 如果一个字符串的头尾两个字符不一样，则它一定不是回文的； 否则：  如果里面的子串是回文，则整体为回文； 否则不是回文。      状态转移方程\n记 $dp[i][j]$ 表示子串 $s[i..j]$ 是否为回文子串，则有：\ndp[i][j] = (s[i] == s[j]) \u0026amp;\u0026amp; dp[i + 1][j - 1]   边界条件\n当 $s[i] == s[j]$ 且 $j - i \u0026lt; 3$ 时直接有： $dp[i][j] = true$\n  原题解\n动态规划法\n  二、中心扩散法   核心思路\n遍历每一个索引，以其为中心向两边进行扩散。枚举中心位置的复杂度为 $O(n)$ ，从中心位置得到回文子串的复杂度为 $O(n)$，因此整体复杂度为 $O(N^2)$ 。\n  原题解\n中心扩散法\n  ",
    "ref": "/blog/leetcode-5/"
  },{
    "title": "manjaro安装总结",
    "date": "September 22, 2019",
    "description": "manjaro安装过程",
    "body": "鼓捣了一天 manjaro 系统，在室友的大力帮助下终于把基本的环境、包都配置好了，在此按照系统安装之后的时间顺序稍做记录，以便后续翻阅备用。\n将 pacman 源更改为清华镜像源 pacman 为 manjaro 默认的软件包管理工具，它将一个简单的二进制包格式和易用的构建系统结合了起来。不管软件包是来自官方的 Arch 库还是用户自己创建，Pacman 都能方便的管理。\n但是 pacman 默认源在国外，因此安装包时速度会很慢，所以第一步将 pacman 的源更改为清华镜像源。\n在终端输入以下命令：\nsudo pacman-mirrors -i -c China -m rank 更新系统（所有的包） 在终端输入以下命令：\nsudo pacman -Syyu 安装 alacritty alacritty 是 linux 上一个使用 gpu 进行渲染的终端模拟器（windows 也能安装，本人没试过也不想试，有了 linux 终端谁还记得 windows 呢）。其他简介、优点说明就省了，具体安装如下：（安装包的话找 pacman 就完事儿了）\nsudo pacman -S alacritty 设置 i3 的默认终端为 alacritty（修改 i3 配置文件，文件路径见后文）：\nbindsym $mod+Return exec alacritty 找到这一行并将 exec 后的终端改为 alacritty （上面已修改）。\n安装窗口管理器 i3 i3 是 linux 系统上的一个平铺窗口管理器，简而言之在这里能够用键盘完全代替鼠标进行操作，而且还自带分屏及分屏排列等功能，完虐 windows 手动分屏功能（而且还只支持两分屏及四分屏），具体安装如下：\nsudo pacman -S i3 安装成功后 reboot，在登录界面点击设置图标可选择要进入的桌面环境（i3 或默认安装的 gnome），选择 i3 开始翱翔。\ni3 基础配置 重启后系统会进入 i3 的配置页面，如左图：\n选择 esc，即不使用默认配置。然后显示页面如右图：\n这个页面配置的是 manjaro 的 mod 键（可以和很多键位组成一些快捷键），个人建议选择 alt 键，windows 键太远，而且在机械键盘上有 lalt 和 ralt 两个键，而 windows 只有一个键。\ni3 常用快捷键及设置 在 i3 配置文件中可修改快捷键搭配方式，如：\nbindsym $mod+Shift+h move left 即设置 mod + Shift + h 为向左移动当前窗口。\n以下为我的一些个人 i3 快捷键：\n   快捷键 作用 快捷键 作用     mod + return 新建终端窗口 mod + f 全屏状态切换   mod + h 向左切换窗口 mod + shift + h 向左移动窗口   mod + j 向下切换窗口 mod + shift + j 向下移动窗口   mod + k 向上切换窗口 mod + shift + k 向上移动窗口   mod + l 向右切换窗口 mod + shift + l 向右移动窗口   mod + f 全屏状态切换 mod + d 进入软件打开界面   mod + b 打开默认浏览器 mod + s 以上下标签式（栈）排列窗口    nvi ~/.config/i3/config 其中 nvi 为 neovim 的别名，后面将介绍其相关配置。\n修改默认 shell 环境   安装 zsh\nmanjaro 默认的 shell 环境为 bash。而 zsh 环境比 bash 更方便，因此选择将默认 shell 改为 zsh。\nzsh 的介绍及配置见：终极 Shell——ZSH - 池建强的文章 - 知乎\n各系统 zsh 安装方式见：Installing ZSH\nmanjaro 系统安装 zsh 的命令同上：\nsudo pacman -S zsh   将 zsh 设置为默认 shell\nzsh 安装完成后需要将其设置为默认 shell，命令如下：\nchsh -s $(which zsh)   oh-my-zsh 的安装\noh-my-zsh 是一个 zsh 配置管理框架，可用于安装各种插件和主题更改等功能。\ngithub 主页为：oh-my-zsh\n安装很简单：\ncurl -Lo install.sh https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh 若想更换 zsh 相关配置，修改其配置文件：\nnvi ~/.zshrc 如更换主题（修改配置文件中的 ZSH_THEME 字段）：\n ZSH_THEME=\u0026quot;robbyrussell\u0026rdquo;\n 给命令设置别名（alias）：\n alias py=\u0026quot;python\u0026rdquo;\n 其中等号左边为要设置的别名，右边引号内为原始命令。\n  每次修改 zsh 配置后需要重启终端或输入以下命令应用修改：\nsource ~/.zshrc 安装 vim 用 vim 编辑文本的好处我已经不想多说了，用过的都说好啊！然而 manjaro 竟然不自带 vim，好在有 pacman 管理工具：\nsudo pacman -S vim 安装 neovim neovim 科普文章：\n科普，21 世纪的 Vim - neovim - 亦俊的文章 - 知乎\n安装命令：\nsudo pacman -S neovim 由于从零开始配置 vim 过于麻烦，因此直接使用 github 上的 thinkvim 配置。具体安装及注意事项见：\ngithub hardcoreplayers/ThinkVim\n配置 alacritty 主题 alacritty 配置文件：\n ~/.config/alacritty/alacritty.yml\n 在其中修改 colors 字段的代码即可。具体主题可见：\ngithub eendroroy/alacritty-theme\n用对应主题的配置文件中的 colors 字段覆盖上述字段。\n每次修改配置文件后重启终端即可应用修改。\n字体 修改 alacritty 配置文件中的 fonts 字段。\ncompton compton 是一个合成管理器（我也不知道什么意思），可以给 i3 窗口添加淡入淡出、半透明、阴影等效果，具体介绍见： Arch Linux - Compton\ncompton 的安装及环境依赖见： github tryone144/compton\n配置文件：\n ~/.config/compton.conf\n 修改配置文件后需要关闭重启 compton 以应用修改：\nkillall compton 然后 ctrl + d 搜索 compton 并打开。\n安装并配置好后在 i3 配置文件中添加代码如下：\nexec_always compton 即每次启动 i3 时自动启动 compton。\n其余配置   CapsLock 到 Esc 的映射 CapsLock 占据了重要的位置发挥着最少的最用，Esc 占据了最偏远的位置发着最大的作用。而在 vim 中 Esc 键又是极其重要的，因此有必要将 CapsLock 映射成 Esc。\n具体方法网上有很多教程，试了几个不管用，我个人的最终解决方法为：\n 在家目录下新建.xmodmap 文件  nvi ~./xmodmap 加入以下两行代码：  clear lock keycode 0x42 = Escape 修改 i3 配置文件：  nvi ~/.config/i3/config 添加如下代码：  exec_always xmodmap ~/.xmodmap 即每次启动 i3 时自动应用这个映射。\n但是正确的方法应该是从系统层面将 CapsLock 修改为 Escape，如 Windows 里面修改注册表的方法，但是监于本人还未找到合适方法，先用这个代替吧。\n  安装 variety 到目前为止 i3 还没有一个合适的桌面壁纸呢，因此安装 variety 壁纸管理工具：\nsudo pacman -S variety   安装 arandr arandr 是终端的一个文件浏览器，同时支持 vim 的操作语法，十分方便：\nsudo pacman -S arandr 然后在 i3 配置文件中添加：\nexec_always variety exec_always arandr  即每次启动 i3 时自动启动这两个软件。\n  关于 manjaro 的配置暂时就这么多，以后应该会安装更多软件，到时再作记录。\n总而言之这几天用着 manjaro 感觉工作效率提高了不少，一个字：爽！\n如果你目前还是一个忠实的 windows 用户，同时又是一个程序猿的话，欢迎加入 linux 大家庭！\n",
    "ref": "/blog/manjaro/"
  },{
    "title": "一篇简单的感想&总结",
    "date": "September 14, 2019",
    "description": "感想",
    "body": "最近看到一篇文章：清华大学计算机专业本科这位在「自己写的 CPU 上运行自己写的操作系统」的同学是什么水平？ - 知乎。看完后感受颇深：同龄人简历上写的项目经历，自己竟然连名字是什么意思都看不懂。还没来得及感慨贵系优秀同学与自己之间的巨大差距，今天又仔细阅读了几篇程序员大佬的编程经历回顾博客，真是感到“革命尚未成功，同志仍需努力”的任重道远之情啊！为了勉励自己继续奋力前行，在此记录一下自己这几天的阅读（围观神仙）感想。\n一、保持兴趣与热情 从小看过很多各领域精英的采访记录，具体的各种心路历程、经历分享已经记不清了， 脑海中唯独只留下了一个印象：真正站在顶峰的人，从来不是按部就班跟着老师的步伐成长起来的，更多的是兴趣使然，让自己去学习高于甚至远高于课程的知识。当然我并不是否认一步一个脚印跟着老师踏踏实实学习的重要性。相反，这是一个人成长关键的一步。一个优秀老师的悉心教导，永远胜于自己一个人拿着书本死磕。但若想做到别人做不到的事，学会别人不会的新本领，只能去课本之外寻找答案。\n今年是我在清华软院本科的第三年，当初选择计算机专业，真的是处出于纯粹的兴趣。尽管高中时除了只会用电脑上网玩游戏之外，其他计算机专业知识一窍不通，但填志愿时看着志愿书上数不清的各种专业，我的眼中只有计算机三个字。而这两年走来，虽然见识到了园子里各种各样的大佬，虽然专业课的成绩并不是那么中看，但我依然对编程，对自己的专业保持着极高的热情。而这份热情，也是激励着我每学期都比上学期更加进步的重要原因之一。\n大一上的弹幕游戏大作业、Qt小学期的怪怪水族馆游戏大作业，大二上的新闻网页信息提取大作业，前端小学期的微信小游戏开发大作业以及后端小学期的django图片处理网页的实现，所有的这些任务，几乎都是以一片空白开始，中途也少不了各种bug调试、资料搜索。虽然过程一个比一个困难，但在忍受着被bug支配的痛苦的同时，我也享受着编程带给我的快乐以及任务完成后一个比一个强烈的成就感。可曾试想，若是没有对自己所学知识的兴趣驱使着我不断前行，恐怕自己早已在这场与同龄人相互竞争、成长的博弈中草草退场。\n二、上课真的不能翘 在清华学习了两年，学到的不仅是课上老师讲授的专业知识，还有自己那自以为是的翘课本领：顶着“这课老师讲的真不怎么样”、“反正有ppt，我自己看也能学懂”的各种借口来睡懒觉、翘课、不跟着老师进度来。看了你为什么要来上课并且认真参与这篇文章后发现自己俨然就是作者所言大学生中的一个典型，同时也发现了自己其实一直有注意到但却没有留意的问题：不上课、不认真听讲带来的最直接后果便是无法集中注意力。\n不知什么时候起，我发现自己竟然很难坐在教室听老师讲完一大节甚至一小节课，很难在下定决心赶作业时坚持半个小时以上。这是自己从小“吊儿郎当”、“浮躁”的后遗症。然而进入大学两年之久，我竟没有将它改正，反而让它发展得愈加严重。\n除了注意力无法集中之外，“自学”课程知识带来的更直接的后果是对知识掌握不牢固。人家是上课认认真真听老师讲完全程，认真完成作业，甚至还会课后再次回顾巩固。而自己却是只粗粗略读课件中与作业有关的部分，直到临近考试才将一学期所有的课件临时回顾，后果便是自以为了解、掌握了的知识，在考场中根本想不起具体如何运用。\n这学期是入学以来课程数量最少的一学期，但是一看到摆在课表上的四门专业课，我只能对自己说：真的不能翘了啊喂！再翘真的就死翘翘了啊！\n三、一定要找到节奏 站在大三的起点，回顾自己大一的成绩表，真的只能用不堪入目四字来形容，都xx考的什么玩意儿！线代、微积分、程设甚至体育，都有那么难吗？如果再来一次，我还会考成那样吗?虽然知道自己的回答是不会，但我很清楚永远不会再有第二次了：如果“如果”有用的话，又要努力干什么用呢？\n所幸自己从大二开始良心发现，慢慢找到了在这个园子里生活学习的“节奏”，不仅心态变好了，学习方面也在不断进步，至少大二的专业课绩点也还勉强看得过去，前端小学期的助教和老师也大大方方给了我一个A-。（真的很开心了，自己在家一个人苦苦学习cocos、苦苦盯着屏幕一整天一整天还调不出来bug的十多天没有白费啊！）\n总而言之，除了兴趣、踏实之外，节奏是真的不能少的一个东西：找到节奏，才能安排好时间，才能好好地完成课程之内的工作，才能进一步有时间学习课程之外的新知识，而这些又会对你的学习进行“正反馈”，让你能够更加自信的面对下一阶段的生活学习。\n四、一点反思 当然写了这么多，目的不在于停下来沉浸在短时间、微小的成就上，而是要提醒自己还有很大的进步空间。比如，人家的兴趣在于独立编写行数过万的游戏、独立实现脚本引擎和Pascal语言解释器（进入 2012 \u0026ndash; 回顾我走过的编程之路），而自己的兴趣却被仅仅限制在了课程之内，根本无暇顾及课程之外更加精彩纷呈的世界。\n除此之外，注意力无法长时间集中的问题也亟待解决：一个空有一身口号，到关键时刻却永远无法专注于当下的人，永远只是一个无用之人。\n环顾四周，远比自己优秀的人比比皆是，自己的目标、家人的期望还远远没有达到，那还有什么借口继续驻足原地，止步不前呢？人生没有等出来的美丽，只有拼出来的辉煌。Wanna make it to the top? Go, now.\n",
    "ref": "/blog/blog-review/"
  },{
    "title": "Markdown Syntax Guide",
    "date": "March 11, 2019",
    "description": "Sample article showcasing basic Markdown syntax and formatting for HTML elements.",
    "body": "This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ",
    "ref": "/blog/markdown-syntax/"
  },{
    "title": "About",
    "date": "February 28, 2019",
    "description": "Hugo, the world’s fastest framework for building websites",
    "body": "Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n",
    "ref": "/about/"
  },{
    "title": "Contact",
    "date": "January 1, 0001",
    "description": "",
    "body": "",
    "ref": "/contact/"
  }]
